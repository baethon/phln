{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"baethon/phln Set of small utility functions. Heavily inspired by Ramda.js , adapted for PHP needs. Installation composer require baethon/phln Example usage use Baethon\\Phln\\Phln as P; $aboveMinPoints = P::compose(P::lte(50), P::prop('score')); $onlyPhp = P::pathEq('language.name', 'PHP'); $topScores = collect($users) ->filter(P::both($aboveMinPoints, $onlyPhp)); Note : in the docs P will be used as an alias to Baethon\\Phln\\Phln . Currying Phln methods are loosely curried. A N-ary method will return a function until all arguments are provided. $foo = P::curryN(2, function ($left, $right) { return $left + $right; }); $foo(1); // returns instance of \\Closure $foo(1, 2); // 3 $foo(1)(2); // 3 Partial application Partial application is possible with combination of P::partial() and P::__ const. Partial returns a function which accepts arguments which should \"fill\" gap of missing arguments for callable. $foos = [1, 2, 3]; $mapFoos = P::partial('\\\\array_map', [P::__, $foos]); $mapFoos(function ($f) { return $f + 100; }); // [100, 200, 300] Function composition For function composition phln provides pipe() and compose() functions. $allFoos = P::pipe( P::filter(P::lte(5)), P::map(P::always('foo')) ); $firstFoo = P::compose(P::head(), $allFoos); $allFoos([4, 5, 6]); // ['foo', 'foo'] $firstFoo([4, 5, 6]); // 'foo' Using methods as references Some of phln methods accept callable as an argument. To pass another macro as a reference call it without any arguments. $collection = [1, 2, 3, 4]; P::reduce(P::sum(), $collection); // 10 Also, you can use P::raw() method wich returns uncurried macro, or pointer to Phln method. Extending Baethon\\Phln\\Phln is macroable . This means that it can be extened using macro() method: P::macro('foo', function () { return 'foo'; }); P::foo(); // 'foo' Note about objects The library takes terminology from Ramda. In most cases, it's perfectly fine, until one gets to the concept of object . Ramda treats objects as dictionaries. In JavaScript, there's only one type which can act as a dictionary. It's ... object . In PHP things get complicated. It's possible to use arrays and objects as dictionaries. This way Phln has to treat both of those types as an object . For compatibility reason, all functions which return object will return array . Testing ./vendor/bin/phpunit","title":"Home"},{"location":"#baethonphln","text":"Set of small utility functions. Heavily inspired by Ramda.js , adapted for PHP needs.","title":"baethon/phln"},{"location":"#installation","text":"composer require baethon/phln","title":"Installation"},{"location":"#example-usage","text":"use Baethon\\Phln\\Phln as P; $aboveMinPoints = P::compose(P::lte(50), P::prop('score')); $onlyPhp = P::pathEq('language.name', 'PHP'); $topScores = collect($users) ->filter(P::both($aboveMinPoints, $onlyPhp)); Note : in the docs P will be used as an alias to Baethon\\Phln\\Phln .","title":"Example usage"},{"location":"#currying","text":"Phln methods are loosely curried. A N-ary method will return a function until all arguments are provided. $foo = P::curryN(2, function ($left, $right) { return $left + $right; }); $foo(1); // returns instance of \\Closure $foo(1, 2); // 3 $foo(1)(2); // 3","title":"Currying"},{"location":"#partial-application","text":"Partial application is possible with combination of P::partial() and P::__ const. Partial returns a function which accepts arguments which should \"fill\" gap of missing arguments for callable. $foos = [1, 2, 3]; $mapFoos = P::partial('\\\\array_map', [P::__, $foos]); $mapFoos(function ($f) { return $f + 100; }); // [100, 200, 300]","title":"Partial application"},{"location":"#function-composition","text":"For function composition phln provides pipe() and compose() functions. $allFoos = P::pipe( P::filter(P::lte(5)), P::map(P::always('foo')) ); $firstFoo = P::compose(P::head(), $allFoos); $allFoos([4, 5, 6]); // ['foo', 'foo'] $firstFoo([4, 5, 6]); // 'foo'","title":"Function composition"},{"location":"#using-methods-as-references","text":"Some of phln methods accept callable as an argument. To pass another macro as a reference call it without any arguments. $collection = [1, 2, 3, 4]; P::reduce(P::sum(), $collection); // 10 Also, you can use P::raw() method wich returns uncurried macro, or pointer to Phln method.","title":"Using methods as references"},{"location":"#extending","text":"Baethon\\Phln\\Phln is macroable . This means that it can be extened using macro() method: P::macro('foo', function () { return 'foo'; }); P::foo(); // 'foo'","title":"Extending"},{"location":"#note-about-objects","text":"The library takes terminology from Ramda. In most cases, it's perfectly fine, until one gets to the concept of object . Ramda treats objects as dictionaries. In JavaScript, there's only one type which can act as a dictionary. It's ... object . In PHP things get complicated. It's possible to use arrays and objects as dictionaries. This way Phln has to treat both of those types as an object . For compatibility reason, all functions which return object will return array .","title":"Note about objects"},{"location":"#testing","text":"./vendor/bin/phpunit","title":"Testing"},{"location":"internals/","text":"Macros All macros are located in src/macros directory. They're segregated by a namespace - a general \"field\" of their responsibility. Each macro should be defined in a separated file. It's allowed to define macros aliases . use Baethon\\Phln\\Phln as P; P::macro('foo', function () { return 'foo'; }); P::alias('bar', 'foo'); Every new macro should be added to bundle.php file which is responsible for loading them. CLI generator It's possible to scaffold new macro by using create:macro command. ./bin/console.php create:macro math power Docs Every new macro should be documented in Markdown docs located in docs/ directory.","title":"Internals"},{"location":"internals/#macros","text":"All macros are located in src/macros directory. They're segregated by a namespace - a general \"field\" of their responsibility. Each macro should be defined in a separated file. It's allowed to define macros aliases . use Baethon\\Phln\\Phln as P; P::macro('foo', function () { return 'foo'; }); P::alias('bar', 'foo'); Every new macro should be added to bundle.php file which is responsible for loading them.","title":"Macros"},{"location":"internals/#cli-generator","text":"It's possible to scaffold new macro by using create:macro command. ./bin/console.php create:macro math power","title":"CLI generator"},{"location":"internals/#docs","text":"Every new macro should be documented in Markdown docs located in docs/ directory.","title":"Docs"},{"location":"methods/","text":"Below is list of Phln methods which are not considered as a macro. alias (String, String) -> Null Added in: v2.0 Creates an alias of a macro. P::alias('falsey', 'F'); P::falsey(); // false raw String -> (*... -> *) Added in: v2.0 Returns an uncurried version of a macro or a reference to one of Phln methods. $sum = P::raw('sum'); $arity = P::raw('arity'); $sum(1, 2); // 3 $arity($sum); // 2 arity (*... -> *) -> Number Added in: v1.0 Takes a function and returns its arity. P::arity('var_dump'); // 1 For curried macros this method will always return 1 . curry (* \u2192 a) \u2192 (* \u2192 a) Added in: v1.0 Returns a curried equivalent of the provided function. Curried function doesn't require providing arguments one at a time. If f is a ternary function and g is P::curry(f) , the following are equivalent. g(1)(2)(3) g(1)(2, 3) g(1, 2)(3) g(1, 2, 3) curryN (Number, (* \u2192 a)) \u2192 (* \u2192 a) Added in: v1.0 Returns a curried equivalent of the provided function, with the specified arity. Curried function doesn't require providing arguments one at a time. If f is a ternary function and g is P::curryN(3, f) , the following are equivalent. g(1)(2)(3) g(1)(2, 3) g(1, 2)(3) g(1, 2, 3) macro (String, (* -> a)) -> Null Added in: v2.0 Adds new macro to Phln . hasMacro String -> Boolean Added in: v2.0 Checks if given macro (or it's alias) is defined.","title":"Methods"},{"location":"methods/#alias","text":"(String, String) -> Null Added in: v2.0 Creates an alias of a macro. P::alias('falsey', 'F'); P::falsey(); // false","title":"alias"},{"location":"methods/#raw","text":"String -> (*... -> *) Added in: v2.0 Returns an uncurried version of a macro or a reference to one of Phln methods. $sum = P::raw('sum'); $arity = P::raw('arity'); $sum(1, 2); // 3 $arity($sum); // 2","title":"raw"},{"location":"methods/#arity","text":"(*... -> *) -> Number Added in: v1.0 Takes a function and returns its arity. P::arity('var_dump'); // 1 For curried macros this method will always return 1 .","title":"arity"},{"location":"methods/#curry","text":"(* \u2192 a) \u2192 (* \u2192 a) Added in: v1.0 Returns a curried equivalent of the provided function. Curried function doesn't require providing arguments one at a time. If f is a ternary function and g is P::curry(f) , the following are equivalent. g(1)(2)(3) g(1)(2, 3) g(1, 2)(3) g(1, 2, 3)","title":"curry"},{"location":"methods/#curryn","text":"(Number, (* \u2192 a)) \u2192 (* \u2192 a) Added in: v1.0 Returns a curried equivalent of the provided function, with the specified arity. Curried function doesn't require providing arguments one at a time. If f is a ternary function and g is P::curryN(3, f) , the following are equivalent. g(1)(2)(3) g(1)(2, 3) g(1, 2)(3) g(1, 2, 3)","title":"curryN"},{"location":"methods/#macro","text":"(String, (* -> a)) -> Null Added in: v2.0 Adds new macro to Phln .","title":"macro"},{"location":"methods/#hasmacro","text":"String -> Boolean Added in: v2.0 Checks if given macro (or it's alias) is defined.","title":"hasMacro"},{"location":"macros/collection/","text":"all (a -> Boolean) -> [a] -> Boolean Added in: v1.0 Returns true if all elements of array match the predicate, false otherwise. $onlyTwos = P::all(P::equals(2)); $onlyTwos([1, 2, 2]); // false any (a -> Boolean) -> [a] -> Boolean Added in: v1.0 Returns true if at least one of array elements match the predicate, false otherwise. $hasTwos = P::any(P::equals(2)); $hasTwos([1, 2, 3, 4]); // true append a -> [a] -> [a] String -> String -> String Added in: v1.0 Returns a new list containing the contents of the given list or string, followed by the given element. P::append(3, [1, 2]); // [1, 2, 3] P::append([3], [1, 2]); // [1, 2, [3]] P::append('foo', 'bar'); // 'barfoo' chunk Number -> [a] -> [[a]] Number -> String -> [String] Added in: v1.0 Chunks an array or string into arrays with size elements. The last chunk may contain less than size elements. P::chunk(2, [1, 2, 3, 4]); // [[1, 2], [3, 4]] P::chunk(2, 'hello'); // ['he', 'll', 'o'] collapse [[*], [*]] -> [*, *] Added in: v1.0 Flattens array elements by one level concat [a] -> [a] -> [a] String -> String -> String Added in: v1.0 Returns the result of concatenating the given lists or strings. Note: P::concat expects both arguments to be of the same type, otherwise it will throw an exception. P::concat([1, 2], [3]); // [1, 2, 3] P::concat('foo', 'bar'); // 'foobar' contains a -> [a] -> Boolean String -> String -> Boolean Added in: v1.0 Returns true if the specified value is equal, P::equals terms, to at least one element of the given collection; false otherwise. P::contains(1, [1, 2, 3]); // true P::contains('foo', 'foobar'); // true filter (a -> Boolean) -> [a] -> Boolean Added in: v1.0 Filters elements of an array using a callback function P::filter(equals(1), [1, 2, 3]); // [1] find (a -> Boolean) -> [a] -> a Added in: v1.0 Returns the first element of the list which matches the predicate, or null if no element matches. $xs = [['a' => 1], ['a' => 2], ['a' => 3]]; P::find(equals(['a' => 1]), $xs); // ['a' => 1] flatMap (a -> b) -> [a] -> [b] Added in: v1.0 Maps a function over list and concatenates results $duplicateElements = P::flatMap(function ($i) { return [$i, $i]; }); $duplicateElements([1, 2]); // [1, 1, 2, 2] fromPairs [[k, v]] -> {k: v} Added in: v1.2 Creates a new key => value object from list of pairs. P::fromPairs([['foo', 1], ['bar', 2]]); // [ 'foo' => 1, 'bar' => 2 ] groupBy (a -> String) -> [a] -> { String: [a] } Added in: v1.2 Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function on each element, and grouping the results according to values returned. P::groupBy( function (int $i) { return ($i % 2 === 0) ? 'even' : 'odd'; }, [1, 2, 3, 4] ); // ['odd' => [1, 3], 'even' => [2, 4]] head [a] -> a | Null String -> String Added in: v1.0 Returns the first element of a given list or string P::head([1, 2, 3]); // 1 P::head([]); // null P::head('foo'); // 'f' P::head('f'); // '' init [a] -> [a] String -> String Added in: v1.0 Returns all but the last element of the given array or string. P::init([1, 2, 3]); // [1, 2] P::init([1, 2]); // [1] P::init([1]); // [] P::init([]); // [] P::init('lorem'); // 'lore' P::init('lo'); // 'l' P::init('l'); // '' P::init(''); // '' join String -> [a] -> String Added in: v1.0 Returns a string made by inserting the separator between each element and concatenating all the elements into a single string. $spacer = P::join(' '); $spacer([1, 2, 3]); // '1 2 3' last [a] -> a String -> String Added in: v1.0 Returns the last element of the given list or string. P::last([1, 2, 3]); // 3 P::last([]); // null P::last('foo'); // 'o' P::last('f'); // 'f' length [a] -> Number String -> Number Added in: v1.0 Returns the number of elements in the array or string. P::length('lorem'); // 5 map (a -> b) -> [a] -> [b] Functor f => (a -> b) -> f a -> f b Added in: v1.0 Applies the callback to the elements of the given array. It's possible to pass instance of Functor instead of an array. map() will apply callback to functors value and return a functor of a same type. Changelog: v2.1 - added support for Functor mapIndexed ((a, i) -> b) -> [a] -> [b] Added in: v1.0 Applies the callback to the elements of the given arrays Callback will receive index of iterated value as a second argument. none (a -> Boolean) -> [a] -> Boolean Added in: v1.0 Returns true if no elements of the list match the predicate, false otherwise. $isEven = function ($i) { return $i % 2 === 0; }; P::none($isEven, [1, 3, 5]); // true P::none($isEven, [1, 3, 5, 6]); // false nth Number -> [a] -> a | Null Added in: v1.0 Returns the nth element of the given list or string. If n is negative the element at index length - n is returned. P::nth(1, [1, 2, 3]); // 2 P::nth(-1, [1, 2, 3]); // 3 partition (a -> Bool) -> [a] -> [[a], [a]] Added in: v1.2 Takes a predicate and a collection and returns the pair of filterable objects of the same type of elements which do and do not satisfy, the predicate, respectively. P::partition( P::contains('foo'), ['foo bar', 'bar', 'foo'] ); // [['foo bar', 'foo'], ['bar']] pluck k -> [{k: v}] -> v Added in: v1.0 Returns a new list by plucking the same named property off all objects in the list supplied. $list = [['a' => 1], ['a' => 2]]; P::pluck('a', $list); // [1, 2] prepend a -> [a] -> [a] String -> String -> String Added in: v1.0 Returns a new collection with the given element at the front, followed by the contents of the list or string. P::prepend(3, [1, 2]); // [3, 1, 2] P::prepend([3], [1, 2]); // [[3], 1, 2] P::prepend('foo', 'bar'); // [[3], 1, 2] range Integer a => a -> a -> [a] Added in: v1.0 Returns a list of numbers from from (inclusive) to to (exclusive). P::range(0, 3); // [0, 1, 2] reduce ((a, b) -> a) -> a -> [b] -> a Added in: v1.0 Returns a single item by iterating through the list, successively calling the iterator function and passing it an accumulator value and the current value from the array, and then passing the result to the next call. The iterator function receives two values: ( acc , value ). P::reduce(P::subtract, 0, [1, 2, 3, 4]); // ((((0 - 1) - 2) - 3) - 4) => -10 reject (a -> Boolean) -> [a] -> [a] Added in: v1.0 The negation of filter . $isOdd = function ($i) { return $i % 2 === 1; }; P::reject($isOdd, [1, 2, 3, 4]); // [2, 4] reverse [a] -> [a] String -> String Added in: v1.0 Returns a new list or string with the elements in reverse order. P::reverse([1, 2, 3]); // [3, 2, 1] P::reverse('foo'); // 'oof' slice Integer -> Integer -> [a] -> [a] Integer -> Integer -> String -> String Added in: v1.0 Extracts a slice of the array or string $takeTwo = P::slice(0, 2); $takeTwo([1, 2, 3]); // [1, 2] sort ((a, a) -> Number) -> [a] -> [a] Added in: v1.0 Returns a copy of the list, sorted according to the comparator function, which should accept two values at a time and return a negative number if the first value is smaller, a positive number if it's larger, and zero if they are equal. $diff = function ($a, $b) { return $a - $b; }; P::sort($diff, [3, 2, 1]); // [1, 2, 3] sortBy (a -> b) -> [a] -> [a] Added in: v1.0 Sorts the list according to the supplied function. $alice = ['name' => 'alice']; $bob = ['name' => 'bob']; $clara = ['name' => 'clara']; $people = [$bob, $clara, $alice]; P::soryBy(P::prop('name'), $people); // [$alice, $bob, $clara] tail [a] -> [a] String -> String Added in: v1.0 Returns all but the first element of the given array or string P::tail([1, 2, 3]); // [2, 3] P::tail([1]); // [] P::tail([]); // [] P::tail('lorem'); // 'orem' P::tail('l'); // '' P::tail(''); // '' unique [a] -> [a] Added in: v1.0 Returns a new list containing only one copy of each element in the original list. Strict comparision is used to determine equality. P::unique([3, 2, 1, 1, 3, 2]); // [3, 2, 1] update Integer -> a -> [a] -> [a] Added in: v2.1 Returns a new copy of the array with the element at the provided index replaced with the given value. P::update(1, 'foo', ['foo', 'bar']); // ['foo', 'foo'] lensIndex Number -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens whose focus is the specified index. $lens = P::lensIndex(2); $input = [1, 2, 3, 4, 5]; P::view($lens, $input); // 3 P::over($lens, P::inc(), $input); // [1, 2, 4, 4, 5] P::set($lens, 0, $input); // [1, 2, 0, 4, 5]","title":"Collection"},{"location":"macros/collection/#all","text":"(a -> Boolean) -> [a] -> Boolean Added in: v1.0 Returns true if all elements of array match the predicate, false otherwise. $onlyTwos = P::all(P::equals(2)); $onlyTwos([1, 2, 2]); // false","title":"all"},{"location":"macros/collection/#any","text":"(a -> Boolean) -> [a] -> Boolean Added in: v1.0 Returns true if at least one of array elements match the predicate, false otherwise. $hasTwos = P::any(P::equals(2)); $hasTwos([1, 2, 3, 4]); // true","title":"any"},{"location":"macros/collection/#append","text":"a -> [a] -> [a] String -> String -> String Added in: v1.0 Returns a new list containing the contents of the given list or string, followed by the given element. P::append(3, [1, 2]); // [1, 2, 3] P::append([3], [1, 2]); // [1, 2, [3]] P::append('foo', 'bar'); // 'barfoo'","title":"append"},{"location":"macros/collection/#chunk","text":"Number -> [a] -> [[a]] Number -> String -> [String] Added in: v1.0 Chunks an array or string into arrays with size elements. The last chunk may contain less than size elements. P::chunk(2, [1, 2, 3, 4]); // [[1, 2], [3, 4]] P::chunk(2, 'hello'); // ['he', 'll', 'o']","title":"chunk"},{"location":"macros/collection/#collapse","text":"[[*], [*]] -> [*, *] Added in: v1.0 Flattens array elements by one level","title":"collapse"},{"location":"macros/collection/#concat","text":"[a] -> [a] -> [a] String -> String -> String Added in: v1.0 Returns the result of concatenating the given lists or strings. Note: P::concat expects both arguments to be of the same type, otherwise it will throw an exception. P::concat([1, 2], [3]); // [1, 2, 3] P::concat('foo', 'bar'); // 'foobar'","title":"concat"},{"location":"macros/collection/#contains","text":"a -> [a] -> Boolean String -> String -> Boolean Added in: v1.0 Returns true if the specified value is equal, P::equals terms, to at least one element of the given collection; false otherwise. P::contains(1, [1, 2, 3]); // true P::contains('foo', 'foobar'); // true","title":"contains"},{"location":"macros/collection/#filter","text":"(a -> Boolean) -> [a] -> Boolean Added in: v1.0 Filters elements of an array using a callback function P::filter(equals(1), [1, 2, 3]); // [1]","title":"filter"},{"location":"macros/collection/#find","text":"(a -> Boolean) -> [a] -> a Added in: v1.0 Returns the first element of the list which matches the predicate, or null if no element matches. $xs = [['a' => 1], ['a' => 2], ['a' => 3]]; P::find(equals(['a' => 1]), $xs); // ['a' => 1]","title":"find"},{"location":"macros/collection/#flatmap","text":"(a -> b) -> [a] -> [b] Added in: v1.0 Maps a function over list and concatenates results $duplicateElements = P::flatMap(function ($i) { return [$i, $i]; }); $duplicateElements([1, 2]); // [1, 1, 2, 2]","title":"flatMap"},{"location":"macros/collection/#frompairs","text":"[[k, v]] -> {k: v} Added in: v1.2 Creates a new key => value object from list of pairs. P::fromPairs([['foo', 1], ['bar', 2]]); // [ 'foo' => 1, 'bar' => 2 ]","title":"fromPairs"},{"location":"macros/collection/#groupby","text":"(a -> String) -> [a] -> { String: [a] } Added in: v1.2 Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function on each element, and grouping the results according to values returned. P::groupBy( function (int $i) { return ($i % 2 === 0) ? 'even' : 'odd'; }, [1, 2, 3, 4] ); // ['odd' => [1, 3], 'even' => [2, 4]]","title":"groupBy"},{"location":"macros/collection/#head","text":"[a] -> a | Null String -> String Added in: v1.0 Returns the first element of a given list or string P::head([1, 2, 3]); // 1 P::head([]); // null P::head('foo'); // 'f' P::head('f'); // ''","title":"head"},{"location":"macros/collection/#init","text":"[a] -> [a] String -> String Added in: v1.0 Returns all but the last element of the given array or string. P::init([1, 2, 3]); // [1, 2] P::init([1, 2]); // [1] P::init([1]); // [] P::init([]); // [] P::init('lorem'); // 'lore' P::init('lo'); // 'l' P::init('l'); // '' P::init(''); // ''","title":"init"},{"location":"macros/collection/#join","text":"String -> [a] -> String Added in: v1.0 Returns a string made by inserting the separator between each element and concatenating all the elements into a single string. $spacer = P::join(' '); $spacer([1, 2, 3]); // '1 2 3'","title":"join"},{"location":"macros/collection/#last","text":"[a] -> a String -> String Added in: v1.0 Returns the last element of the given list or string. P::last([1, 2, 3]); // 3 P::last([]); // null P::last('foo'); // 'o' P::last('f'); // 'f'","title":"last"},{"location":"macros/collection/#length","text":"[a] -> Number String -> Number Added in: v1.0 Returns the number of elements in the array or string. P::length('lorem'); // 5","title":"length"},{"location":"macros/collection/#map","text":"(a -> b) -> [a] -> [b] Functor f => (a -> b) -> f a -> f b Added in: v1.0 Applies the callback to the elements of the given array. It's possible to pass instance of Functor instead of an array. map() will apply callback to functors value and return a functor of a same type. Changelog: v2.1 - added support for Functor","title":"map"},{"location":"macros/collection/#mapindexed","text":"((a, i) -> b) -> [a] -> [b] Added in: v1.0 Applies the callback to the elements of the given arrays Callback will receive index of iterated value as a second argument.","title":"mapIndexed"},{"location":"macros/collection/#none","text":"(a -> Boolean) -> [a] -> Boolean Added in: v1.0 Returns true if no elements of the list match the predicate, false otherwise. $isEven = function ($i) { return $i % 2 === 0; }; P::none($isEven, [1, 3, 5]); // true P::none($isEven, [1, 3, 5, 6]); // false","title":"none"},{"location":"macros/collection/#nth","text":"Number -> [a] -> a | Null Added in: v1.0 Returns the nth element of the given list or string. If n is negative the element at index length - n is returned. P::nth(1, [1, 2, 3]); // 2 P::nth(-1, [1, 2, 3]); // 3","title":"nth"},{"location":"macros/collection/#partition","text":"(a -> Bool) -> [a] -> [[a], [a]] Added in: v1.2 Takes a predicate and a collection and returns the pair of filterable objects of the same type of elements which do and do not satisfy, the predicate, respectively. P::partition( P::contains('foo'), ['foo bar', 'bar', 'foo'] ); // [['foo bar', 'foo'], ['bar']]","title":"partition"},{"location":"macros/collection/#pluck","text":"k -> [{k: v}] -> v Added in: v1.0 Returns a new list by plucking the same named property off all objects in the list supplied. $list = [['a' => 1], ['a' => 2]]; P::pluck('a', $list); // [1, 2]","title":"pluck"},{"location":"macros/collection/#prepend","text":"a -> [a] -> [a] String -> String -> String Added in: v1.0 Returns a new collection with the given element at the front, followed by the contents of the list or string. P::prepend(3, [1, 2]); // [3, 1, 2] P::prepend([3], [1, 2]); // [[3], 1, 2] P::prepend('foo', 'bar'); // [[3], 1, 2]","title":"prepend"},{"location":"macros/collection/#range","text":"Integer a => a -> a -> [a] Added in: v1.0 Returns a list of numbers from from (inclusive) to to (exclusive). P::range(0, 3); // [0, 1, 2]","title":"range"},{"location":"macros/collection/#reduce","text":"((a, b) -> a) -> a -> [b] -> a Added in: v1.0 Returns a single item by iterating through the list, successively calling the iterator function and passing it an accumulator value and the current value from the array, and then passing the result to the next call. The iterator function receives two values: ( acc , value ). P::reduce(P::subtract, 0, [1, 2, 3, 4]); // ((((0 - 1) - 2) - 3) - 4) => -10","title":"reduce"},{"location":"macros/collection/#reject","text":"(a -> Boolean) -> [a] -> [a] Added in: v1.0 The negation of filter . $isOdd = function ($i) { return $i % 2 === 1; }; P::reject($isOdd, [1, 2, 3, 4]); // [2, 4]","title":"reject"},{"location":"macros/collection/#reverse","text":"[a] -> [a] String -> String Added in: v1.0 Returns a new list or string with the elements in reverse order. P::reverse([1, 2, 3]); // [3, 2, 1] P::reverse('foo'); // 'oof'","title":"reverse"},{"location":"macros/collection/#slice","text":"Integer -> Integer -> [a] -> [a] Integer -> Integer -> String -> String Added in: v1.0 Extracts a slice of the array or string $takeTwo = P::slice(0, 2); $takeTwo([1, 2, 3]); // [1, 2]","title":"slice"},{"location":"macros/collection/#sort","text":"((a, a) -> Number) -> [a] -> [a] Added in: v1.0 Returns a copy of the list, sorted according to the comparator function, which should accept two values at a time and return a negative number if the first value is smaller, a positive number if it's larger, and zero if they are equal. $diff = function ($a, $b) { return $a - $b; }; P::sort($diff, [3, 2, 1]); // [1, 2, 3]","title":"sort"},{"location":"macros/collection/#sortby","text":"(a -> b) -> [a] -> [a] Added in: v1.0 Sorts the list according to the supplied function. $alice = ['name' => 'alice']; $bob = ['name' => 'bob']; $clara = ['name' => 'clara']; $people = [$bob, $clara, $alice]; P::soryBy(P::prop('name'), $people); // [$alice, $bob, $clara]","title":"sortBy"},{"location":"macros/collection/#tail","text":"[a] -> [a] String -> String Added in: v1.0 Returns all but the first element of the given array or string P::tail([1, 2, 3]); // [2, 3] P::tail([1]); // [] P::tail([]); // [] P::tail('lorem'); // 'orem' P::tail('l'); // '' P::tail(''); // ''","title":"tail"},{"location":"macros/collection/#unique","text":"[a] -> [a] Added in: v1.0 Returns a new list containing only one copy of each element in the original list. Strict comparision is used to determine equality. P::unique([3, 2, 1, 1, 3, 2]); // [3, 2, 1]","title":"unique"},{"location":"macros/collection/#update","text":"Integer -> a -> [a] -> [a] Added in: v2.1 Returns a new copy of the array with the element at the provided index replaced with the given value. P::update(1, 'foo', ['foo', 'bar']); // ['foo', 'foo']","title":"update"},{"location":"macros/collection/#lensindex","text":"Number -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens whose focus is the specified index. $lens = P::lensIndex(2); $input = [1, 2, 3, 4, 5]; P::view($lens, $input); // 3 P::over($lens, P::inc(), $input); // [1, 2, 4, 4, 5] P::set($lens, 0, $input); // [1, 2, 0, 4, 5]","title":"lensIndex"},{"location":"macros/function/","text":"F * -> (* -> Boolean) Added in: v1.0 Returns a function that always returns false . T * -> (* -> Boolean) Added in: v1.0 Returns a function that always returns true . always a -> (* -> a) Added in: v1.0 Returns a function that always returns the given value. For non-primitives the value returned is a reference to the original value. $foo = P::always('foo'); $foo(); // 'foo' apply (*... -> a) -> [*] -> a Added in: v1.0 Applies function fn to the argument list. This is useful for creating a fixed-arity function from a variadic function. P::apply(P::sum, [1, 2]); // 3 compose [((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)] -> (a, b, ..., n) -> z) ((a, b, ..., n) -> o, (o -> p), ..., (x -> y), (y -> z)) -> (a, b, ..., n) ->z) Added in: v1.0 Performs left-to-right function composition. The leftmost function may have any arity; the remaining functions must be unary. Note : The result of pipe is not automatically curried. Changelog: v2.2 - added support for variadic arguments identity a -> a Added in: v1.0 A function that does nothing but return the parameter supplied to it. Good as a default or placeholder function. P::identity(1) === 1; // 'true' invoker Int -> String -> (a -> b -> c -> ... -> n -> Object -> *) Added in: v1.2 Turns a named method with a specified arity into a function that can be called directly supplied with arguments and a target object. The returned function is curried and accepts arity + 1 parameters where the final parameter is the target object. $greeter = new class () { public function hello($name, $lastname) { return \"Hello, {$name} {$lastname}!\"; } }; $helloToJon = P::invoker(2, 'hello')('Jon'); $helloToJon('Snow'); // 'Hello, Jon Snow!' negate (*... -> *) -> (*... -> Boolean) Added in: v1.0 Creates a function that negates the result of the predicate. $isEven = function ($i) { return $i % 2 === 0; }; P::filter(P::negate($isEven), [1, 2, 3, 4, 5, 6]); // [1, 3, 5] of a -> [a] Added in: v1.0 Returns a singleton array containing the value provided. P::of(null); // [null] P::of('a'); // ['a'] once (a... -> b) -> (a... -> b) Added in: v1.0 Accepts a function fn and returns a function that guards invocation of fn such that fn can only ever be called once, no matter how many times the returned function is invoked. The first value calculated is returned in subsequent invocations. $f = P::once('\\rand'); $f(1, 100); // 4 $f(1, 100); // 4 $f(1, 100); // 4 partial ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x) Added in: v1.0 Takes a function f and a list of arguments, and returns a function g . When applied, g returns the result of applying f to the arguments provided initially followed by the arguments provided to g . Special placeholder value P::__ may be used to specify \"gaps\", allowing partial application of any combination of arguments, regardless of their positions. $subtractFive = P::partial(P::subtract, [P::__, 5]); $subtractFive(10); // 5 partialRight ((a, b, c, d, ..., n) -> x) -> [d, ..., n] -> ((a, b, c) -> x) Added in: v1.2 Takes a function f and a list of arguments, and returns a function g . When applied, g returns the result of applying f to the arguments provided initially followed by the arguments provided to g . $hello = function ($salutations, $name, $lastname) { return \"{$salutations}, {$name} {$lastname}\"; }; $f = P::partialRight($hello, ['Jon', 'Stark']); $f('Hello'); // 'Hello, Jon Stark' pipe [((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)] -> (a, b, ..., n) -> z) (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a, b, ..., n) -> z) Added in: v1.0 Performs left-to-right function composition. The leftmost function may have any arity; the remaining functions must be unary. Note : The result of pipe is not automatically curried. Changelog: v2.2 - added support for variadic arguments swap (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z) Added in: v1.0 Returns a new function much like the supplied one, except that the first two arguments' order is reversed. $serialize = function ($a, $b) { return \"a:{$a},b:{$b}\"; }; P::swap($serialize)(2, 1); // 'a:1,b:2' tap (a -> *) -> a -> a Added in: v1.0 Runs the given function with the supplied object, then returns the object. $dump = P::tap('var_dump'); $dump('foo'); // var_dumps('foo'); returns 'foo' throwException String -> [*] -> (*... -> Null) Added in: v1.0 Returns callback which throws given exception. Note: exceptions are considered as side-efects. Use it with caution. $break = P::throwException(\\LogicException::class, []); $break(); // -> throw new \\LogicException() unapply ([*...] -> a) -> (*... -> a) Added in: v1.0 Takes a function fn , which takes a single array argument, and returns a function which: * takes any number of positional arguments; * passes these arguments to fn as an array and returns the result In other words, P::unapply derives a variadic function from a function which takes an array. P::unapply is the inverse of P::apply . P::unapply('\\\\json_encode')(1, 2, 3); // [1,2,3] nAry Number -> (* -> a) -> (* -> a) Added in: v2.0 Wraps a function of any arity (including nullary) in a function that accepts exactly n parameters. Any extraneous parameters will not be passed to the supplied function. P::nAry(2, function (...$args) { return $args; })(1, 2, 3, 4); // [1, 2] unary Number -> (* -> b) -> (a -> b) Added in: v2.0 Wraps a function of any arity (including nullary) in a function that accepts exactly 1 parameter. Any extraneous parameters will not be passed to the supplied function. P::unary(function (...$args) { return $args; })(1, 2, 3, 4); // [1] binary Number -> (* -> c) -> ((a, b) -> c) Added in: v2.0 Wraps a function of any arity (including nullary) in a function that accepts exactly 2 parameters. Any extraneous parameters will not be passed to the supplied function. P::binary(function (...$args) { return $args; })(1, 2, 3, 4); // [1, 2] trampoline (* -> *) -> (* -> *) Added in: 2.2.0 Creates a stack-safe tail recurrent function. As long as wrapped function returns thunk (function which calls the recursive function) trampoline will loop over its results. Calling $this() inside the function will return its thunk . Wrapped function should not return instance of Closure as an end-result (it will trigger next loop iteration). $fib = P::trampoline(function ($n, $accum1 = 1, $accum2 = 1) { return $n < 2 ? $accum1 : $this($n - 1, $accum1 + $accum2, $accum1); }); $fib(4); // 5","title":"Function"},{"location":"macros/function/#f","text":"* -> (* -> Boolean) Added in: v1.0 Returns a function that always returns false .","title":"F"},{"location":"macros/function/#t","text":"* -> (* -> Boolean) Added in: v1.0 Returns a function that always returns true .","title":"T"},{"location":"macros/function/#always","text":"a -> (* -> a) Added in: v1.0 Returns a function that always returns the given value. For non-primitives the value returned is a reference to the original value. $foo = P::always('foo'); $foo(); // 'foo'","title":"always"},{"location":"macros/function/#apply","text":"(*... -> a) -> [*] -> a Added in: v1.0 Applies function fn to the argument list. This is useful for creating a fixed-arity function from a variadic function. P::apply(P::sum, [1, 2]); // 3","title":"apply"},{"location":"macros/function/#compose","text":"[((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)] -> (a, b, ..., n) -> z) ((a, b, ..., n) -> o, (o -> p), ..., (x -> y), (y -> z)) -> (a, b, ..., n) ->z) Added in: v1.0 Performs left-to-right function composition. The leftmost function may have any arity; the remaining functions must be unary. Note : The result of pipe is not automatically curried. Changelog: v2.2 - added support for variadic arguments","title":"compose"},{"location":"macros/function/#identity","text":"a -> a Added in: v1.0 A function that does nothing but return the parameter supplied to it. Good as a default or placeholder function. P::identity(1) === 1; // 'true'","title":"identity"},{"location":"macros/function/#invoker","text":"Int -> String -> (a -> b -> c -> ... -> n -> Object -> *) Added in: v1.2 Turns a named method with a specified arity into a function that can be called directly supplied with arguments and a target object. The returned function is curried and accepts arity + 1 parameters where the final parameter is the target object. $greeter = new class () { public function hello($name, $lastname) { return \"Hello, {$name} {$lastname}!\"; } }; $helloToJon = P::invoker(2, 'hello')('Jon'); $helloToJon('Snow'); // 'Hello, Jon Snow!'","title":"invoker"},{"location":"macros/function/#negate","text":"(*... -> *) -> (*... -> Boolean) Added in: v1.0 Creates a function that negates the result of the predicate. $isEven = function ($i) { return $i % 2 === 0; }; P::filter(P::negate($isEven), [1, 2, 3, 4, 5, 6]); // [1, 3, 5]","title":"negate"},{"location":"macros/function/#of","text":"a -> [a] Added in: v1.0 Returns a singleton array containing the value provided. P::of(null); // [null] P::of('a'); // ['a']","title":"of"},{"location":"macros/function/#once","text":"(a... -> b) -> (a... -> b) Added in: v1.0 Accepts a function fn and returns a function that guards invocation of fn such that fn can only ever be called once, no matter how many times the returned function is invoked. The first value calculated is returned in subsequent invocations. $f = P::once('\\rand'); $f(1, 100); // 4 $f(1, 100); // 4 $f(1, 100); // 4","title":"once"},{"location":"macros/function/#partial","text":"((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x) Added in: v1.0 Takes a function f and a list of arguments, and returns a function g . When applied, g returns the result of applying f to the arguments provided initially followed by the arguments provided to g . Special placeholder value P::__ may be used to specify \"gaps\", allowing partial application of any combination of arguments, regardless of their positions. $subtractFive = P::partial(P::subtract, [P::__, 5]); $subtractFive(10); // 5","title":"partial"},{"location":"macros/function/#partialright","text":"((a, b, c, d, ..., n) -> x) -> [d, ..., n] -> ((a, b, c) -> x) Added in: v1.2 Takes a function f and a list of arguments, and returns a function g . When applied, g returns the result of applying f to the arguments provided initially followed by the arguments provided to g . $hello = function ($salutations, $name, $lastname) { return \"{$salutations}, {$name} {$lastname}\"; }; $f = P::partialRight($hello, ['Jon', 'Stark']); $f('Hello'); // 'Hello, Jon Stark'","title":"partialRight"},{"location":"macros/function/#pipe","text":"[((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)] -> (a, b, ..., n) -> z) (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a, b, ..., n) -> z) Added in: v1.0 Performs left-to-right function composition. The leftmost function may have any arity; the remaining functions must be unary. Note : The result of pipe is not automatically curried. Changelog: v2.2 - added support for variadic arguments","title":"pipe"},{"location":"macros/function/#swap","text":"(a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z) Added in: v1.0 Returns a new function much like the supplied one, except that the first two arguments' order is reversed. $serialize = function ($a, $b) { return \"a:{$a},b:{$b}\"; }; P::swap($serialize)(2, 1); // 'a:1,b:2'","title":"swap"},{"location":"macros/function/#tap","text":"(a -> *) -> a -> a Added in: v1.0 Runs the given function with the supplied object, then returns the object. $dump = P::tap('var_dump'); $dump('foo'); // var_dumps('foo'); returns 'foo'","title":"tap"},{"location":"macros/function/#throwexception","text":"String -> [*] -> (*... -> Null) Added in: v1.0 Returns callback which throws given exception. Note: exceptions are considered as side-efects. Use it with caution. $break = P::throwException(\\LogicException::class, []); $break(); // -> throw new \\LogicException()","title":"throwException"},{"location":"macros/function/#unapply","text":"([*...] -> a) -> (*... -> a) Added in: v1.0 Takes a function fn , which takes a single array argument, and returns a function which: * takes any number of positional arguments; * passes these arguments to fn as an array and returns the result In other words, P::unapply derives a variadic function from a function which takes an array. P::unapply is the inverse of P::apply . P::unapply('\\\\json_encode')(1, 2, 3); // [1,2,3]","title":"unapply"},{"location":"macros/function/#nary","text":"Number -> (* -> a) -> (* -> a) Added in: v2.0 Wraps a function of any arity (including nullary) in a function that accepts exactly n parameters. Any extraneous parameters will not be passed to the supplied function. P::nAry(2, function (...$args) { return $args; })(1, 2, 3, 4); // [1, 2]","title":"nAry"},{"location":"macros/function/#unary","text":"Number -> (* -> b) -> (a -> b) Added in: v2.0 Wraps a function of any arity (including nullary) in a function that accepts exactly 1 parameter. Any extraneous parameters will not be passed to the supplied function. P::unary(function (...$args) { return $args; })(1, 2, 3, 4); // [1]","title":"unary"},{"location":"macros/function/#binary","text":"Number -> (* -> c) -> ((a, b) -> c) Added in: v2.0 Wraps a function of any arity (including nullary) in a function that accepts exactly 2 parameters. Any extraneous parameters will not be passed to the supplied function. P::binary(function (...$args) { return $args; })(1, 2, 3, 4); // [1, 2]","title":"binary"},{"location":"macros/function/#trampoline","text":"(* -> *) -> (* -> *) Added in: 2.2.0 Creates a stack-safe tail recurrent function. As long as wrapped function returns thunk (function which calls the recursive function) trampoline will loop over its results. Calling $this() inside the function will return its thunk . Wrapped function should not return instance of Closure as an end-result (it will trigger next loop iteration). $fib = P::trampoline(function ($n, $accum1 = 1, $accum2 = 1) { return $n < 2 ? $accum1 : $this($n - 1, $accum1 + $accum2, $accum1); }); $fib(4); // 5","title":"trampoline"},{"location":"macros/logic/","text":"allPass [(*... -> Boolean) -> *... -> Boolean Added in: v1.0 Takes a list of predicates and returns a predicate that returns true for a given list of arguments if every one of the provided predicates is satisfied by those arguments. The function returned is a curried function whose arity matches that of the highest-arity predicate. $ace = P::propEq('rank', 'A'); $spades = P::propEq('suit', '\u2660\ufe0e'); $aceOfSpades = P::allPass([$ace, $spades]); $aceOfSpades(['rank' => 'A', 'suit' => '\u2660\ufe0e']); // true both (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean) Boolean -> Boolean -> Boolean Added in: v1.0 Returns true when both of two provided values are truthy. This function is polymorphic and supports two cases: 1. when both values are predicates it will return wrapper function which call to the two functions in an && operation, returning true if both of the functions will return truthy value. 2. when both values are booleans it will return result of && operation $gt10 = P::partial(P::gt, [P::__, 10]); $lt20 = P::partial(P::lt, [P::__, 20]); $f = P::both($gt10, $lt20); $f(12); // true P::both(true, false); // false cond [[(*\u2026 \u2192 Boolean),(*\u2026 \u2192 *)]] \u2192 (*\u2026 \u2192 *) Added in: v1.0 Returns a function, fn , which encapsulates if/else , if/else logic. P::cond takes a list of [ predicate , transformer ] pairs. All of the arguments to fn are applied to each of the predicates in turn until one returns a truth-y value, at which point fn returns the result of applying its arguments to the corresponding transformer . If none of the predicates matches, fn returns null. $fn = P::cond([ [P::equals(0), P::always('water freezes at 0\u00b0C')], [P::equals(100), P::always('water boils at 100\u00b0C')], [P::T, function(temp) { return 'nothing special happens at ' + temp + '\u00b0C'; }] ]); $fn(0); //=> 'water freezes at 0\u00b0C' $fn(50); //=> 'nothing special happens at 50\u00b0C' $fn(100); //=> 'water boils at 100\u00b0C' defaultTo a -> b -> b | a Added in: v1.0 Returns the second argument if it is not null ; otherwise the first argument is returned. P::defaultTo(42, null); // 42 P::defaultTo(42, 'life'); // 'life' either (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean) Boolean -> Boolean -> Boolean Added in: v1.0 Returns true when one of two provided values is truthy. This function is polymorphic and supports two cases: 1. when both values are predicates it will return wrapper function which call to the two functions in an || operation, returning true if at least one of the functions will return truthy value. 2. when both values are booleans it will return result of || operation $lt10 = P::partial(P::lt, [P::__, 10]); $gt20 = P::partial(P::gt, [P::__, 20]); $f = P::either($lt10, $gt20); $f(12); // false $f(9); // true $f(21); // true P::either(true, false); // true ifElse (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *) Added in: v1.0 Creates a function that will process either the onTrue or the onFalse function depending upon the result of the condition predicate. $modulo15 = P::swap(P::modulo)(15); $fizzbuzz = P::ifElse( P::compose(P::equals(0), $modulo15), P::always('fizzbuzz'), P::identity ); $fizzbuzz(15); // 'fizzbuzz' $fizzbuzz(1); // 1 isEmpty a -> Boolean Added in: v1.0 Returns true if the given value is its type's empty value; false otherwise. Note unlike \\empty() this function will consider numbers, booleans and NULL as non-empty. P::isEmpty(''); // true P::isEmpty([]); // true P::isEmpty(new stdClass); // true P::isEmpty(0); // false P::isEmpty(null); // false P::isEmpty(false); // false P::isEmpty(true); // false not * -> Boolean Added in: v1.0 A function that returns the ! of its argument. It will return true when passed false-y value, and false when passed a truth-y one. P::not(0); // true P::not(true); // false","title":"Logic"},{"location":"macros/logic/#allpass","text":"[(*... -> Boolean) -> *... -> Boolean Added in: v1.0 Takes a list of predicates and returns a predicate that returns true for a given list of arguments if every one of the provided predicates is satisfied by those arguments. The function returned is a curried function whose arity matches that of the highest-arity predicate. $ace = P::propEq('rank', 'A'); $spades = P::propEq('suit', '\u2660\ufe0e'); $aceOfSpades = P::allPass([$ace, $spades]); $aceOfSpades(['rank' => 'A', 'suit' => '\u2660\ufe0e']); // true","title":"allPass"},{"location":"macros/logic/#both","text":"(*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean) Boolean -> Boolean -> Boolean Added in: v1.0 Returns true when both of two provided values are truthy. This function is polymorphic and supports two cases: 1. when both values are predicates it will return wrapper function which call to the two functions in an && operation, returning true if both of the functions will return truthy value. 2. when both values are booleans it will return result of && operation $gt10 = P::partial(P::gt, [P::__, 10]); $lt20 = P::partial(P::lt, [P::__, 20]); $f = P::both($gt10, $lt20); $f(12); // true P::both(true, false); // false","title":"both"},{"location":"macros/logic/#cond","text":"[[(*\u2026 \u2192 Boolean),(*\u2026 \u2192 *)]] \u2192 (*\u2026 \u2192 *) Added in: v1.0 Returns a function, fn , which encapsulates if/else , if/else logic. P::cond takes a list of [ predicate , transformer ] pairs. All of the arguments to fn are applied to each of the predicates in turn until one returns a truth-y value, at which point fn returns the result of applying its arguments to the corresponding transformer . If none of the predicates matches, fn returns null. $fn = P::cond([ [P::equals(0), P::always('water freezes at 0\u00b0C')], [P::equals(100), P::always('water boils at 100\u00b0C')], [P::T, function(temp) { return 'nothing special happens at ' + temp + '\u00b0C'; }] ]); $fn(0); //=> 'water freezes at 0\u00b0C' $fn(50); //=> 'nothing special happens at 50\u00b0C' $fn(100); //=> 'water boils at 100\u00b0C'","title":"cond"},{"location":"macros/logic/#defaultto","text":"a -> b -> b | a Added in: v1.0 Returns the second argument if it is not null ; otherwise the first argument is returned. P::defaultTo(42, null); // 42 P::defaultTo(42, 'life'); // 'life'","title":"defaultTo"},{"location":"macros/logic/#either","text":"(*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean) Boolean -> Boolean -> Boolean Added in: v1.0 Returns true when one of two provided values is truthy. This function is polymorphic and supports two cases: 1. when both values are predicates it will return wrapper function which call to the two functions in an || operation, returning true if at least one of the functions will return truthy value. 2. when both values are booleans it will return result of || operation $lt10 = P::partial(P::lt, [P::__, 10]); $gt20 = P::partial(P::gt, [P::__, 20]); $f = P::either($lt10, $gt20); $f(12); // false $f(9); // true $f(21); // true P::either(true, false); // true","title":"either"},{"location":"macros/logic/#ifelse","text":"(*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *) Added in: v1.0 Creates a function that will process either the onTrue or the onFalse function depending upon the result of the condition predicate. $modulo15 = P::swap(P::modulo)(15); $fizzbuzz = P::ifElse( P::compose(P::equals(0), $modulo15), P::always('fizzbuzz'), P::identity ); $fizzbuzz(15); // 'fizzbuzz' $fizzbuzz(1); // 1","title":"ifElse"},{"location":"macros/logic/#isempty","text":"a -> Boolean Added in: v1.0 Returns true if the given value is its type's empty value; false otherwise. Note unlike \\empty() this function will consider numbers, booleans and NULL as non-empty. P::isEmpty(''); // true P::isEmpty([]); // true P::isEmpty(new stdClass); // true P::isEmpty(0); // false P::isEmpty(null); // false P::isEmpty(false); // false P::isEmpty(true); // false","title":"isEmpty"},{"location":"macros/logic/#not","text":"* -> Boolean Added in: v1.0 A function that returns the ! of its argument. It will return true when passed false-y value, and false when passed a truth-y one. P::not(0); // true P::not(true); // false","title":"not"},{"location":"macros/math/","text":"add Number a => a -> a -> a Added in: v1.0 Add two values dec Int a => a -> a Added in: v1.0 Decrement its argument divide Number a => a -> a -> a Added in: v1.0 Divide numbers. Equivalent of a / b inc Int a => a -> a Added in: v1.0 Increment its argument mean Number a => [a] -> a Added in: v1.0 Returns the mean of the given list of numbers. P::mean([2, 7, 9]) // 6 median Number a => [a] -> a Added in: v1.0 Returns the median of the given list of numbers. P::median([7, 2, 9]) // 7 P::median([7, 2, 10, 9]) // 8 modulo Number a => a -> a -> a Added in: v1.0 Divides the first parameter by the second and returns the remainder. P::modulo(1, 2) // 1 multiply Number a => a -> a -> a Added in: v1.0 Multiplies two numbers $triple = P::multiply(3); $triple(7); // 21 product Number a => [a] -> a Added in: v1.0 Multiplies together all the elements of a list. P::product([2, 4, 6, 8, 100, 1]); // 38400 subtract Number a => a -> a -> a Added in: v1.0 Subtracts its second argument from its first argument. $complementaryAngle = P::subtract(90); $complementaryAngle(30); //=> 60 sum [Number] -> Number Added in: v1.0 Adds together all the elements of a list. P::sum([1, 2, 3, 4]); // 10","title":"Math"},{"location":"macros/math/#add","text":"Number a => a -> a -> a Added in: v1.0 Add two values","title":"add"},{"location":"macros/math/#dec","text":"Int a => a -> a Added in: v1.0 Decrement its argument","title":"dec"},{"location":"macros/math/#divide","text":"Number a => a -> a -> a Added in: v1.0 Divide numbers. Equivalent of a / b","title":"divide"},{"location":"macros/math/#inc","text":"Int a => a -> a Added in: v1.0 Increment its argument","title":"inc"},{"location":"macros/math/#mean","text":"Number a => [a] -> a Added in: v1.0 Returns the mean of the given list of numbers. P::mean([2, 7, 9]) // 6","title":"mean"},{"location":"macros/math/#median","text":"Number a => [a] -> a Added in: v1.0 Returns the median of the given list of numbers. P::median([7, 2, 9]) // 7 P::median([7, 2, 10, 9]) // 8","title":"median"},{"location":"macros/math/#modulo","text":"Number a => a -> a -> a Added in: v1.0 Divides the first parameter by the second and returns the remainder. P::modulo(1, 2) // 1","title":"modulo"},{"location":"macros/math/#multiply","text":"Number a => a -> a -> a Added in: v1.0 Multiplies two numbers $triple = P::multiply(3); $triple(7); // 21","title":"multiply"},{"location":"macros/math/#product","text":"Number a => [a] -> a Added in: v1.0 Multiplies together all the elements of a list. P::product([2, 4, 6, 8, 100, 1]); // 38400","title":"product"},{"location":"macros/math/#subtract","text":"Number a => a -> a -> a Added in: v1.0 Subtracts its second argument from its first argument. $complementaryAngle = P::subtract(90); $complementaryAngle(30); //=> 60","title":"subtract"},{"location":"macros/math/#sum","text":"[Number] -> Number Added in: v1.0 Adds together all the elements of a list. P::sum([1, 2, 3, 4]); // 10","title":"sum"},{"location":"macros/object/","text":"assoc String -> a -> {k: v} -> {k: v} Added in: v2.1 Makes a shallow clone of an object, setting or overriding the specified property with the given value. All non-primitive properties are copied by reference. P::assoc('b', 2, ['a' => 1]); // ['a' => 1, 'b' => 2] assocPath String -> a -> {k: v} -> {k: v} Added in: v2.1 Makes a shallow clone of an object, setting or overriding the nodes required to create the given path, and placing the specific value at the tail end of that path. Note that this makes shallow copy of each node of the given path. For missing nodes assocPath will create an array. P::assocPath( 'a.b.c', 'foo', ['a' => []] ); // ['a' => ['b' => ['c' => 'foo']]] eqProps k -> {k: v} -> {k: v} -> Boolean Added in: v1.0 Reports whether two objects have the same value, in P::equals terms, for the specified property. P::eqProps('name', ['name' => 'Jon'], ['name' => 'Jon']); // true has k -> {k: v} -> Boolean Returns whether or not an object has a property with the specified name. P::has('foo', ['foo' => 1]); // true hasMethod String -> Object -> Boolean Checks if given object has a method. Returs true only when method is defined and public. Opposite to method_exists() and is_callable() macro will not treat __call() as a valid method. P::hasMethod('test', new stdClass()); // false keys {k: v} -> [k] Added in: v1.0 Returns a list containing the names of array keys. P::keys(['a' => 1, 'b' => 1]); // ['a', 'b'] merge {k: v} -> {k: v} -> {k: v} Added in: v1.0 Create a new object with the keys of the first object merged with the keys of the second object. If a key exists in both objects, the value from the second object will be used. $toDefaults = P::partial(P::merge, [P::__, ['x' => 0]); $toDefaults(['x' => 2, 'y' => 1]); // ['x' => 0, 'y' => 1] objOf String -> a -> { String: a } Added in: v1.2 Creates an object containing a single key:value pair. P::objOf('foo', 'bar'); // ['foo' => 'bar'] omit [String] -> {String: *} -> {String: *} Added in: v1.0 Returns a partial copy of an object omitting the keys specified. P::omit(['a', 'c'], ['a' => 1, 'b' => 2, 'c' => 3]); // ['b' => 2] path String -> {k: v} -> v|Null Added in: v1.0 Returns nested value using \"dot notation\". P::path('a.b', ['a' => ['b' => 'foo']]); // 'foo' P::path('a.b.c', ['a' => ['b' => 'foo']]); // null pathOr String -> a -> {k: v} -> v | a Added in: v1.0 Returns nested value using \"dot notation\". If key is not defined, or value is NULL default value will be returned. P::pathOr('a.b', 'foo', ['a' => ['b' => 1]]); // 1 P::pathOr('a.b', 'foo', ['a' => ['b' => 0]]); // 0 P::pathOr('a.b', 'foo', ['a' => ['b' => null]]); // 'foo' P::pathOr('a.b', 'foo', ['a' => 1]); // 'foo' pick [String] -> {String: *} -> {String: *} Added in: v1.0 Returns a partial copy of an object containing only the keys specified. If the key does not exist, the property is ignored. P::pick(['a'], ['a' => 1, 'b' => 2]); // ['a' => 1] prop k -> {k: v} -> v Added in: v1.0 Returns a function that when supplied an array returns the indicated key of that key, if it exists. props [k] -> {k: v} -> [v] Added in: v1.0 Acts as multiple prop : array of keys in, array of values out. Preserves order. $fullName = P::compose(P::join(' '), P::props(['firstName', 'lastName'])); $fullName(['lastName' => 'Snow', 'firstName' => 'Jon']); // 'Jon Snow' toPairs String k => { k: v } -> [[k, v]] Added in: v1.2 Converts an object into an array of key-value arrays. Note that order of output is not guaranteed. P::toPairs(['foo' => 1, 'bar' => 2]); // [['foo', 1], ['bar', 2]] values {k: v} -> [v] Added in: v1.0 Returns values of supplied object where {String: (* -> Boolean)} -> {String: *} -> Boolean Added in: v1.0 Takes a spec object and a test object; returns true if the test satisfies the spec. Each of the spec's properties must be a predicate function. Each predicate is applied to the value of the corresponding property of the test object. where returns true if all the predicates return true, false otherwise. where is well suited to declaratively expressing constraints for other functions such as filter and find . $verifyJon = P::where([ 'firstName' => P::equals('Jon'), 'lastName' => P::equals('Snow'), ]); $verifyJon(['firstName' => 'Jon', 'lastName' => 'Snow', 'house' => 'Stark']); // true whereEq {String: *} -> {String: *} -> Boolean Added in: v1.0 Takes a spec object and a test object; returns true if the test satisfies the spec, false otherwise. An object satisfies the spec if, for each of the spec's properties, accessing that property of the object gives the same value (in P::equals() terms) as accessing that property of the spec. $verifyJon = P::whereEq(['firstName' => 'Jon', 'lastName' => 'Snow']); $verifyJon(['firstName' => 'Jon', 'lastName' => 'Snow']); // true lens (s -> a) -> ((a, s) -> s) -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens for the given getter and setter functions. The getter \"gets\" the value of the focus; the setter \"sets\" the value of the focus. The setter should not mutate the data structure. $xLens = P::lens(P::prop('x'), P::assoc('x')); P::view($xLens, ['x' => 1, 'y' => 2]); // 1 P::set($xLens, 4, ['x' => 1, 'y' => 2]); // ['x' => 4, 'y' => 2] P::over($xLens, P::inc(), ['x' => 1, 'y' => 2]); // ['x' => 2, 'y' => 2] lensPath String -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens whose focus is the specified path. $lens = P::lensPath('foo.bar'); $input = ['foo' => ['bar' => 1]]; P::view($lens, $input); // 1 P::over($lens, P::inc(), $input); // ['foo' => ['bar' => 2]] P::set($lens, 2, $input); // ['foo' => ['bar' => 2]] lensProp String -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens whose focus is the specified property. $lens = P::lensProp('name'); $input = ['name' => 'Jon']; P::view($lens, $input); // 'Jon' P::over($lens, P::always('Array'), $input); // ['name' => 'Array'] P::set($lens, 'Array', $input); // ['name' => 'Array'] set Lens s a -> a -> s -> s Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns the result of \"setting\" the portion of the given data structure focused by the given lens to the given value. $xLens = P::lensProp('x'); P::set($xLens, 4, ['x' => 1, 'y' => 2]); // ['x' => 4, 'y' => 2] P::set($xLens, 8, ['x' => 1, 'y' => 2]); // ['x' => 8, 'y' => 2] view Lens s a -> s -> a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a \"view\" of the given data structure, determined by the given lens. The lens's focus determines which portion of the data structure is visible. $xLens = P::lensProp('x'); P::view($xLens, ['x' => 1, 'y' => 2]); // 1 P::view($xLens, ['x' => 4, 'y' => 2]); // 4 over Lens s a -> (a -> a) -> s -> s Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns the result of \"setting\" the portion of the given data structure focused by the given lens to the result of applying the given function to the focused value. $headLens = P::lensIndex(0); P::over($headLens, P::always('FOO'), ['foo', 'bar', 'baz']); // ['FOO', 'bar', 'baz']","title":"Object"},{"location":"macros/object/#assoc","text":"String -> a -> {k: v} -> {k: v} Added in: v2.1 Makes a shallow clone of an object, setting or overriding the specified property with the given value. All non-primitive properties are copied by reference. P::assoc('b', 2, ['a' => 1]); // ['a' => 1, 'b' => 2]","title":"assoc"},{"location":"macros/object/#assocpath","text":"String -> a -> {k: v} -> {k: v} Added in: v2.1 Makes a shallow clone of an object, setting or overriding the nodes required to create the given path, and placing the specific value at the tail end of that path. Note that this makes shallow copy of each node of the given path. For missing nodes assocPath will create an array. P::assocPath( 'a.b.c', 'foo', ['a' => []] ); // ['a' => ['b' => ['c' => 'foo']]]","title":"assocPath"},{"location":"macros/object/#eqprops","text":"k -> {k: v} -> {k: v} -> Boolean Added in: v1.0 Reports whether two objects have the same value, in P::equals terms, for the specified property. P::eqProps('name', ['name' => 'Jon'], ['name' => 'Jon']); // true","title":"eqProps"},{"location":"macros/object/#has","text":"k -> {k: v} -> Boolean Returns whether or not an object has a property with the specified name. P::has('foo', ['foo' => 1]); // true","title":"has"},{"location":"macros/object/#hasmethod","text":"String -> Object -> Boolean Checks if given object has a method. Returs true only when method is defined and public. Opposite to method_exists() and is_callable() macro will not treat __call() as a valid method. P::hasMethod('test', new stdClass()); // false","title":"hasMethod"},{"location":"macros/object/#keys","text":"{k: v} -> [k] Added in: v1.0 Returns a list containing the names of array keys. P::keys(['a' => 1, 'b' => 1]); // ['a', 'b']","title":"keys"},{"location":"macros/object/#merge","text":"{k: v} -> {k: v} -> {k: v} Added in: v1.0 Create a new object with the keys of the first object merged with the keys of the second object. If a key exists in both objects, the value from the second object will be used. $toDefaults = P::partial(P::merge, [P::__, ['x' => 0]); $toDefaults(['x' => 2, 'y' => 1]); // ['x' => 0, 'y' => 1]","title":"merge"},{"location":"macros/object/#objof","text":"String -> a -> { String: a } Added in: v1.2 Creates an object containing a single key:value pair. P::objOf('foo', 'bar'); // ['foo' => 'bar']","title":"objOf"},{"location":"macros/object/#omit","text":"[String] -> {String: *} -> {String: *} Added in: v1.0 Returns a partial copy of an object omitting the keys specified. P::omit(['a', 'c'], ['a' => 1, 'b' => 2, 'c' => 3]); // ['b' => 2]","title":"omit"},{"location":"macros/object/#path","text":"String -> {k: v} -> v|Null Added in: v1.0 Returns nested value using \"dot notation\". P::path('a.b', ['a' => ['b' => 'foo']]); // 'foo' P::path('a.b.c', ['a' => ['b' => 'foo']]); // null","title":"path"},{"location":"macros/object/#pathor","text":"String -> a -> {k: v} -> v | a Added in: v1.0 Returns nested value using \"dot notation\". If key is not defined, or value is NULL default value will be returned. P::pathOr('a.b', 'foo', ['a' => ['b' => 1]]); // 1 P::pathOr('a.b', 'foo', ['a' => ['b' => 0]]); // 0 P::pathOr('a.b', 'foo', ['a' => ['b' => null]]); // 'foo' P::pathOr('a.b', 'foo', ['a' => 1]); // 'foo'","title":"pathOr"},{"location":"macros/object/#pick","text":"[String] -> {String: *} -> {String: *} Added in: v1.0 Returns a partial copy of an object containing only the keys specified. If the key does not exist, the property is ignored. P::pick(['a'], ['a' => 1, 'b' => 2]); // ['a' => 1]","title":"pick"},{"location":"macros/object/#prop","text":"k -> {k: v} -> v Added in: v1.0 Returns a function that when supplied an array returns the indicated key of that key, if it exists.","title":"prop"},{"location":"macros/object/#props","text":"[k] -> {k: v} -> [v] Added in: v1.0 Acts as multiple prop : array of keys in, array of values out. Preserves order. $fullName = P::compose(P::join(' '), P::props(['firstName', 'lastName'])); $fullName(['lastName' => 'Snow', 'firstName' => 'Jon']); // 'Jon Snow'","title":"props"},{"location":"macros/object/#topairs","text":"String k => { k: v } -> [[k, v]] Added in: v1.2 Converts an object into an array of key-value arrays. Note that order of output is not guaranteed. P::toPairs(['foo' => 1, 'bar' => 2]); // [['foo', 1], ['bar', 2]]","title":"toPairs"},{"location":"macros/object/#values","text":"{k: v} -> [v] Added in: v1.0 Returns values of supplied object","title":"values"},{"location":"macros/object/#where","text":"{String: (* -> Boolean)} -> {String: *} -> Boolean Added in: v1.0 Takes a spec object and a test object; returns true if the test satisfies the spec. Each of the spec's properties must be a predicate function. Each predicate is applied to the value of the corresponding property of the test object. where returns true if all the predicates return true, false otherwise. where is well suited to declaratively expressing constraints for other functions such as filter and find . $verifyJon = P::where([ 'firstName' => P::equals('Jon'), 'lastName' => P::equals('Snow'), ]); $verifyJon(['firstName' => 'Jon', 'lastName' => 'Snow', 'house' => 'Stark']); // true","title":"where"},{"location":"macros/object/#whereeq","text":"{String: *} -> {String: *} -> Boolean Added in: v1.0 Takes a spec object and a test object; returns true if the test satisfies the spec, false otherwise. An object satisfies the spec if, for each of the spec's properties, accessing that property of the object gives the same value (in P::equals() terms) as accessing that property of the spec. $verifyJon = P::whereEq(['firstName' => 'Jon', 'lastName' => 'Snow']); $verifyJon(['firstName' => 'Jon', 'lastName' => 'Snow']); // true","title":"whereEq"},{"location":"macros/object/#lens","text":"(s -> a) -> ((a, s) -> s) -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens for the given getter and setter functions. The getter \"gets\" the value of the focus; the setter \"sets\" the value of the focus. The setter should not mutate the data structure. $xLens = P::lens(P::prop('x'), P::assoc('x')); P::view($xLens, ['x' => 1, 'y' => 2]); // 1 P::set($xLens, 4, ['x' => 1, 'y' => 2]); // ['x' => 4, 'y' => 2] P::over($xLens, P::inc(), ['x' => 1, 'y' => 2]); // ['x' => 2, 'y' => 2]","title":"lens"},{"location":"macros/object/#lenspath","text":"String -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens whose focus is the specified path. $lens = P::lensPath('foo.bar'); $input = ['foo' => ['bar' => 1]]; P::view($lens, $input); // 1 P::over($lens, P::inc(), $input); // ['foo' => ['bar' => 2]] P::set($lens, 2, $input); // ['foo' => ['bar' => 2]]","title":"lensPath"},{"location":"macros/object/#lensprop","text":"String -> Lens s a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a lens whose focus is the specified property. $lens = P::lensProp('name'); $input = ['name' => 'Jon']; P::view($lens, $input); // 'Jon' P::over($lens, P::always('Array'), $input); // ['name' => 'Array'] P::set($lens, 'Array', $input); // ['name' => 'Array']","title":"lensProp"},{"location":"macros/object/#set","text":"Lens s a -> a -> s -> s Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns the result of \"setting\" the portion of the given data structure focused by the given lens to the given value. $xLens = P::lensProp('x'); P::set($xLens, 4, ['x' => 1, 'y' => 2]); // ['x' => 4, 'y' => 2] P::set($xLens, 8, ['x' => 1, 'y' => 2]); // ['x' => 8, 'y' => 2]","title":"set"},{"location":"macros/object/#view","text":"Lens s a -> s -> a Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns a \"view\" of the given data structure, determined by the given lens. The lens's focus determines which portion of the data structure is visible. $xLens = P::lensProp('x'); P::view($xLens, ['x' => 1, 'y' => 2]); // 1 P::view($xLens, ['x' => 4, 'y' => 2]); // 4","title":"view"},{"location":"macros/object/#over","text":"Lens s a -> (a -> a) -> s -> s Lens s a = Functor f => (a -> f a) -> s -> f s Added in: v2.1 Returns the result of \"setting\" the portion of the given data structure focused by the given lens to the result of applying the given function to the focused value. $headLens = P::lensIndex(0); P::over($headLens, P::always('FOO'), ['foo', 'bar', 'baz']); // ['FOO', 'bar', 'baz']","title":"over"},{"location":"macros/relation/","text":"clamp Number a => a -> a -> a -> a Added in: v1.0 Restricts a number to be within a range. P::clamp(-1, 1, -100); // -1 P::clamp(-1, 1, 100); // 1 P::clamp(-1, 1, 0); // 0 difference [*] -> [*] -> [*] Added in: v1.0 Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list. P::difference([1, 2, 3, 4], [3, 4, 5, 6]); // [1, 2] equals a -> b -> Boolean Added in: v1.0 Returns true if its arguments are equivalent, false otherwise. P::equals(1, 1); // true P::equals(1, '1'); // false P::equals(1, 2); // false gt Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is greater than the second; false otherwise. P::gt(2, 1); // true gte Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is greater than or equal to the second; false otherwise. P::gte(2, 1); // true P::gte(2, 2); // true P::gte(2, 3); // false intersection [*] -> [*] -> [*] Added in: v1.0 Combines two lists into a set composed of those elements common to both lists. P::intersection([1, 2, 3, 4], [6, 4, 5]); // [4] lt Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is less than the second; false otherwise. P::lt(1, 2); // true P::lt(3, 2); // false P::lt(2, 2); // false lte Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is less than or equal to the second; false otherwise. P::lte(1, 2); // true max a -> a -> a Added in: v1.0 Returns the larger of its two arguments. min a -> a -> a Added in: v1.0 Returns the smaller of its two arguments. P::min(1, -1); // -1 pathEq String -> a -> {a} -> Boolean Added in: v1.0 Determines whether a nested path on an object has a specific value, in equals() terms. P::pathEq('foo.bar', 1, ['foo' => ['bar' => 1]]); // true propEq k -> a -> {k: a} -> Boolean Added in: v1.0 Returns true if the specified object property is equal, in equals() terms, to the given value; false otherwise. P::propEq('name', 'Jon', ['name' => 'Jon']); // true","title":"Relation"},{"location":"macros/relation/#clamp","text":"Number a => a -> a -> a -> a Added in: v1.0 Restricts a number to be within a range. P::clamp(-1, 1, -100); // -1 P::clamp(-1, 1, 100); // 1 P::clamp(-1, 1, 0); // 0","title":"clamp"},{"location":"macros/relation/#difference","text":"[*] -> [*] -> [*] Added in: v1.0 Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list. P::difference([1, 2, 3, 4], [3, 4, 5, 6]); // [1, 2]","title":"difference"},{"location":"macros/relation/#equals","text":"a -> b -> Boolean Added in: v1.0 Returns true if its arguments are equivalent, false otherwise. P::equals(1, 1); // true P::equals(1, '1'); // false P::equals(1, 2); // false","title":"equals"},{"location":"macros/relation/#gt","text":"Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is greater than the second; false otherwise. P::gt(2, 1); // true","title":"gt"},{"location":"macros/relation/#gte","text":"Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is greater than or equal to the second; false otherwise. P::gte(2, 1); // true P::gte(2, 2); // true P::gte(2, 3); // false","title":"gte"},{"location":"macros/relation/#intersection","text":"[*] -> [*] -> [*] Added in: v1.0 Combines two lists into a set composed of those elements common to both lists. P::intersection([1, 2, 3, 4], [6, 4, 5]); // [4]","title":"intersection"},{"location":"macros/relation/#lt","text":"Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is less than the second; false otherwise. P::lt(1, 2); // true P::lt(3, 2); // false P::lt(2, 2); // false","title":"lt"},{"location":"macros/relation/#lte","text":"Ord a => a -> a -> Boolean Added in: v1.0 Returns true if the first argument is less than or equal to the second; false otherwise. P::lte(1, 2); // true","title":"lte"},{"location":"macros/relation/#max","text":"a -> a -> a Added in: v1.0 Returns the larger of its two arguments.","title":"max"},{"location":"macros/relation/#min","text":"a -> a -> a Added in: v1.0 Returns the smaller of its two arguments. P::min(1, -1); // -1","title":"min"},{"location":"macros/relation/#patheq","text":"String -> a -> {a} -> Boolean Added in: v1.0 Determines whether a nested path on an object has a specific value, in equals() terms. P::pathEq('foo.bar', 1, ['foo' => ['bar' => 1]]); // true","title":"pathEq"},{"location":"macros/relation/#propeq","text":"k -> a -> {k: a} -> Boolean Added in: v1.0 Returns true if the specified object property is equal, in equals() terms, to the given value; false otherwise. P::propEq('name', 'Jon', ['name' => 'Jon']); // true","title":"propEq"},{"location":"macros/string/","text":"match RegExp -> String -> String|Null RegExp -> String -> [String] Added in: v1.0 Tests a regular expression against a String. Returns found string, or NULL . When regular expression has 'global' modifier function will return array of found strings. If regular expression contains groups match() will return only matching groups (in an order defined in regular expression). P::match('/([a-z](o))/i', 'Lorem ipsum dolor'); // 'Lo' P::match('/([a-z](o))/ig', 'Lorem ipsum dolor'); // ['Lo', 'do', 'lo'] P::match('/return (\\w)/', 'return integer'); // 'integer' regexp String -> RegExp Added in: v1.0 Converts given string to RegExp object P::regexp('/foo/ig'); // => new \\phln\\RegExp('/foo/', 'ig'); replace RegExp -> String -> String -> String Added in: v1.0 Replace a regex match in a string with a replacement. When regular expression has 'global' modifier all matching strings will be replaced. Otherwise only first matching string will be replaced. P::replace('/foo/', 'bar', 'foo foo foo'); // 'bar foo foo' P::replace('/foo/g', 'bar', 'foo foo foo'); // 'bar bar bar' split String -> String -> [String] RegExp -> String -> [String] Added in: v1.0 Splits a string into an array of strings based on the given regular expression or separator. It's possible to split string P::split('/', 'a/b'); // ['a', 'b'] test RegExp -> String -> Bool String -> String -> Bool Added in: v1.2 Determines whether a given string matches a given regular expression. P::test('/foo/', 'foobar'); // true","title":"String"},{"location":"macros/string/#match","text":"RegExp -> String -> String|Null RegExp -> String -> [String] Added in: v1.0 Tests a regular expression against a String. Returns found string, or NULL . When regular expression has 'global' modifier function will return array of found strings. If regular expression contains groups match() will return only matching groups (in an order defined in regular expression). P::match('/([a-z](o))/i', 'Lorem ipsum dolor'); // 'Lo' P::match('/([a-z](o))/ig', 'Lorem ipsum dolor'); // ['Lo', 'do', 'lo'] P::match('/return (\\w)/', 'return integer'); // 'integer'","title":"match"},{"location":"macros/string/#regexp","text":"String -> RegExp Added in: v1.0 Converts given string to RegExp object P::regexp('/foo/ig'); // => new \\phln\\RegExp('/foo/', 'ig');","title":"regexp"},{"location":"macros/string/#replace","text":"RegExp -> String -> String -> String Added in: v1.0 Replace a regex match in a string with a replacement. When regular expression has 'global' modifier all matching strings will be replaced. Otherwise only first matching string will be replaced. P::replace('/foo/', 'bar', 'foo foo foo'); // 'bar foo foo' P::replace('/foo/g', 'bar', 'foo foo foo'); // 'bar bar bar'","title":"replace"},{"location":"macros/string/#split","text":"String -> String -> [String] RegExp -> String -> [String] Added in: v1.0 Splits a string into an array of strings based on the given regular expression or separator. It's possible to split string P::split('/', 'a/b'); // ['a', 'b']","title":"split"},{"location":"macros/string/#test","text":"RegExp -> String -> Bool String -> String -> Bool Added in: v1.2 Determines whether a given string matches a given regular expression. P::test('/foo/', 'foobar'); // true","title":"test"},{"location":"macros/type/","text":"is String -> a -> Boolean Added in: v1.0 See if value is of given type . Internally this function uses \\gettype() with few support of few aliases: * bool - alias for boolean type * float - alias for double type * callable - checks if $value is valid callback * function - same as callable * class FQN - will check if supplied object is instance of given class P::is('bool', true); // true P::is(\\stdClass::class, new \\stdClass); // true P::is(float, 1.1); // true typeCond [[String, (*... -> *)]] -> (*... -> *) Added in: v1.0 Returns a function, fn , which encapsulates if/else , if/else , . .. logic. P::typeCond takes a list of [ type , transformer ] pairs. Type is converted to predicate matching type of variable (in terms of P::is() ). All of the arguments to fn are applied to each of the predicates in turn until one returns a truth-y value, at which point fn returns the result of applying its arguments to the corresponding transformer . If none of the predicates matches, fn returns null. $count = P::typeCond([ ['string', '\\\\mb_strlen'], ['array', '\\\\count'], [P::T(), P::always(0)], ]); $count('foo'); // 3 $count(['f', 'o', 'o']); // 3 $count(new stdClass); // 0","title":"Type"},{"location":"macros/type/#is","text":"String -> a -> Boolean Added in: v1.0 See if value is of given type . Internally this function uses \\gettype() with few support of few aliases: * bool - alias for boolean type * float - alias for double type * callable - checks if $value is valid callback * function - same as callable * class FQN - will check if supplied object is instance of given class P::is('bool', true); // true P::is(\\stdClass::class, new \\stdClass); // true P::is(float, 1.1); // true","title":"is"},{"location":"macros/type/#typecond","text":"[[String, (*... -> *)]] -> (*... -> *) Added in: v1.0 Returns a function, fn , which encapsulates if/else , if/else , . .. logic. P::typeCond takes a list of [ type , transformer ] pairs. Type is converted to predicate matching type of variable (in terms of P::is() ). All of the arguments to fn are applied to each of the predicates in turn until one returns a truth-y value, at which point fn returns the result of applying its arguments to the corresponding transformer . If none of the predicates matches, fn returns null. $count = P::typeCond([ ['string', '\\\\mb_strlen'], ['array', '\\\\count'], [P::T(), P::always(0)], ]); $count('foo'); // 3 $count(['f', 'o', 'o']); // 3 $count(new stdClass); // 0","title":"typeCond"}]}