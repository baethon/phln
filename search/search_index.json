{
    "docs": [
        {
            "location": "/", 
            "text": "baethon/phln\n\n\nA practical functional library for PHP developers.\n\n\nHeavily inspired by \nRamda.js\n, adapted for PHP needs.\n\n\nInstallation\n\n\ncomposer require baethon/phln\n\n\n\n\nExample usage\n\n\nphln\n defines set of functions which can be used individualy:\n\n\nuse const phln\\fn\\T;\nuse function phln\\fn\\always;\nuse function phln\\logic\\cond;\nuse function phln\\relation\\euqals;\n\n$fooBars = cond([\n    [equals(5), always('foo')],\n    [T, always('bar')],\n]);\n\n$fooBars(5); // foo\n\n\n\n\n... or through \nphln\\Phln\n static wrapper:\n\n\nuse phln\\Phln as P;\n\n$fooBars = P::cond([\n    [P::equals(5), P::always('foo')],\n    [P::T, P::always('bar')],\n]);\n\n\n\n\nLater in docs every \nP::\n reference will be used as a mental shortcut to \nphln\\Phln::\n.\n\n\nCurrying\n\n\nBy default \nmost\n of functions defined in \nphln\n namespace are loosely curried. Functions are unary, however it's possible to pass to them more then one argument. Those arguments will be passed to the returned functions.\n\n\n$foo = P::curryN(2, function ($left, $right) {\n    return $left + $right;\n});\n\n$foo(1); // returns instance of \\Closure\n$foo(1, 2); // 3\n$foo(1)(2); // 3\n\n\n\n\nPartial application\n\n\nPartial application is possible with combination of \nP::partial()\n and \nP::__\n const. Partial returns a function which accepts arguments which should \"fill\" gap of missing arguments for callable.\n\n\n$foos = [1, 2, 3];\n$mapFoos = P::partial('\\\\array_map', [P::__, $foos]);\n$mapFoos(function ($f) {\n    return $f + 100;\n}); // [100, 200, 300]\n\n\n\n\nFunction composition\n\n\nFor basic function composition \nphln\n provides \npipe()\n and \ncompose()\n functions.\n\n\n$allFoos = P::pipe([\n    P::filter(P::lte(5)),\n    P::map(P::always('foo')),\n]);\n\n$firstFoo = P::compose([P::head, $allFoos]);\n\n$allFoos([4, 5, 6]); // ['foo', 'foo']\n$firstFoo([4, 5, 6]); // 'foo'\n\n\n\n\nAbout function references\n\n\nMany of \nphln\n functions accept \ncallable\n type. PHP does not allow to pass imported function as a callable reference. Instead it's required to pass a string reference (functions fully qualified name) as a \"callback\":\n\n\nuse function phln\\math\\sum;\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, sum); // WRONG\narray_reduce($collection, 'phln\\\\math\\\\sum'); // 10\n\n\n\n\nphln\n covers this problem by exporting string constants \"pointing\" to corresponding functions:\n\n\nuse const phln\\math\\sum; // Notice `const` keyword\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, sum); // 10\n\n\n\n\nIt's possible to import \nboth\n function and constant:\n\n\nuse const phln\\math\\sum;\nuse function phln\\math\\sum;\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, sum); // 10\n\nsum(4, 3); // 7\n\n\n\n\nUnfortunatelly this approach generates overhead of import statements. For this reason I suggest using \nphln\\Phln\n static wrapper.\n\n\nuse phln\\Phln as P;\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, P::sum); // 10\n\nP::sum(4, 3); // 7\n\n\n\n\nPrefixed functions\n\n\nDue to internal organization and some PHP limitations \nphln\n exports functions and consts with special prefixes.\n\n\n\ud835\udc53 function\n\n\nThose are uncurried versions of functions used internally by \nphln\n. They contain the main logic of the function and proper typehinting.\n\n\nNote about objects\n\n\nThe library takes terminology from Ramda. In most cases, it's perfectly fine, until one gets to the concept of \nobject\n.\n\n\nRamda treats \nobjects\n as dictionaries. In JavaScript, there's only one type which can act as a dictionary. It's ... \nobject\n.\n\n\nIn PHP things get complicated. It's possible to use arrays and objects as dictionaries. This way \nPhln\n has to treat both of those types as an \nobject\n.\n\n\nFor compatibility reason, all functions which return \nobject\n will return \narray\n.", 
            "title": "baethon/phln"
        }, 
        {
            "location": "/#baethonphln", 
            "text": "A practical functional library for PHP developers.  Heavily inspired by  Ramda.js , adapted for PHP needs.", 
            "title": "baethon/phln"
        }, 
        {
            "location": "/#installation", 
            "text": "composer require baethon/phln", 
            "title": "Installation"
        }, 
        {
            "location": "/#example-usage", 
            "text": "phln  defines set of functions which can be used individualy:  use const phln\\fn\\T;\nuse function phln\\fn\\always;\nuse function phln\\logic\\cond;\nuse function phln\\relation\\euqals;\n\n$fooBars = cond([\n    [equals(5), always('foo')],\n    [T, always('bar')],\n]);\n\n$fooBars(5); // foo  ... or through  phln\\Phln  static wrapper:  use phln\\Phln as P;\n\n$fooBars = P::cond([\n    [P::equals(5), P::always('foo')],\n    [P::T, P::always('bar')],\n]);  Later in docs every  P::  reference will be used as a mental shortcut to  phln\\Phln:: .", 
            "title": "Example usage"
        }, 
        {
            "location": "/#currying", 
            "text": "By default  most  of functions defined in  phln  namespace are loosely curried. Functions are unary, however it's possible to pass to them more then one argument. Those arguments will be passed to the returned functions.  $foo = P::curryN(2, function ($left, $right) {\n    return $left + $right;\n});\n\n$foo(1); // returns instance of \\Closure\n$foo(1, 2); // 3\n$foo(1)(2); // 3", 
            "title": "Currying"
        }, 
        {
            "location": "/#partial-application", 
            "text": "Partial application is possible with combination of  P::partial()  and  P::__  const. Partial returns a function which accepts arguments which should \"fill\" gap of missing arguments for callable.  $foos = [1, 2, 3];\n$mapFoos = P::partial('\\\\array_map', [P::__, $foos]);\n$mapFoos(function ($f) {\n    return $f + 100;\n}); // [100, 200, 300]", 
            "title": "Partial application"
        }, 
        {
            "location": "/#function-composition", 
            "text": "For basic function composition  phln  provides  pipe()  and  compose()  functions.  $allFoos = P::pipe([\n    P::filter(P::lte(5)),\n    P::map(P::always('foo')),\n]);\n\n$firstFoo = P::compose([P::head, $allFoos]);\n\n$allFoos([4, 5, 6]); // ['foo', 'foo']\n$firstFoo([4, 5, 6]); // 'foo'", 
            "title": "Function composition"
        }, 
        {
            "location": "/#about-function-references", 
            "text": "Many of  phln  functions accept  callable  type. PHP does not allow to pass imported function as a callable reference. Instead it's required to pass a string reference (functions fully qualified name) as a \"callback\":  use function phln\\math\\sum;\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, sum); // WRONG\narray_reduce($collection, 'phln\\\\math\\\\sum'); // 10  phln  covers this problem by exporting string constants \"pointing\" to corresponding functions:  use const phln\\math\\sum; // Notice `const` keyword\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, sum); // 10  It's possible to import  both  function and constant:  use const phln\\math\\sum;\nuse function phln\\math\\sum;\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, sum); // 10\n\nsum(4, 3); // 7  Unfortunatelly this approach generates overhead of import statements. For this reason I suggest using  phln\\Phln  static wrapper.  use phln\\Phln as P;\n\n$collection = [1, 2, 3, 4];\narray_reduce($collection, P::sum); // 10\n\nP::sum(4, 3); // 7", 
            "title": "About function references"
        }, 
        {
            "location": "/#prefixed-functions", 
            "text": "Due to internal organization and some PHP limitations  phln  exports functions and consts with special prefixes.", 
            "title": "Prefixed functions"
        }, 
        {
            "location": "/#f-function", 
            "text": "Those are uncurried versions of functions used internally by  phln . They contain the main logic of the function and proper typehinting.", 
            "title": "\ud835\udc53 function"
        }, 
        {
            "location": "/#note-about-objects", 
            "text": "The library takes terminology from Ramda. In most cases, it's perfectly fine, until one gets to the concept of  object .  Ramda treats  objects  as dictionaries. In JavaScript, there's only one type which can act as a dictionary. It's ...  object .  In PHP things get complicated. It's possible to use arrays and objects as dictionaries. This way  Phln  has to treat both of those types as an  object .  For compatibility reason, all functions which return  object  will return  array .", 
            "title": "Note about objects"
        }, 
        {
            "location": "/internals/", 
            "text": "Function file\n\n\nFunction should be defined in it's own file. In fact this file stores definition of two functions:\n\n\n\n\nmain function\n (the one which is exprted) - a simple wrapper for curried version of \n\ud835\udc53 function\n\n\n\ud835\udc53 function\n - holds the main logic and typehinting of the function.\n\n\n\n\nThis structure is maintened only for \n\ud835\udc53 function\n with arity \n 1.\n\n\nFor example, definition of \nsum()\n could look like this:\n\n\nfunction sum(int $a = null, int $b = null)\n{\n    return curryN(2, \ud835\udc53sum, func_get_args());\n}\n\nfunction \ud835\udc53sum(int $a, int $b): int\n{\n    return $a + $b;\n}\n\n\n\n\nExample has missing function constants. In such case there are also two defined constants:\n\n\n\n\nmain const\n - points to the wrapper\n\n\n\ud835\udc53 const\n - points to \n\ud835\udc53 function\n; it's used mostly internally\n\n\n\n\nconst sum = '\\\\phln\\\\math\\\\sum';\nconst \ud835\udc53sum = '\\\\phln\\\\math\\\\\ud835\udc53sum';\n\n\n\n\nAdding new function - build pipeline\n\n\nCreating new function\n\n\nFirst step is to create a new function. It can be done using \ncreate:fn\n command.\n\n\n./bin/console.php create:fn namespace fnName\n\n\n\n\nThis command will generate from template function with test case.\nName of the function has to be unique in scope of all \nphln\n functions.\n\n\nGenerating static wrapper\n\n\nWhen function is done it should be added to \nphln\\Phln\n class.\nThis class is result of \ncreate:bundle\n command so I suggest to use it to add newly created function.\n\n\n./bin/console.php create:bundle\n\n\n\n\nGenerating docs\n\n\nSome parts of docs are compiled from PHPDocs of functions defined in \nphln\\Phln\n class.\nTo compile new version of docs (once the class is created) use \ncreate:docs\n command.\n\n\n./bin/console.php create:docs\n\n\n\n\nTesting\n\n\nphln\n uses PHPUnit to run tests.\n\n\nAbout \nPhln\\Build\\PhpUnit\\TestCase\n\n\nPhln\\Build\\PhpUnit\\TestCase\n allows to run test case in two different \"contexts\". By default it runs tests using main function. Combined with \nTestBundleListener\n it will be executed once again with \"context\" of \nphln\\Phln\n class (test case will use appropriate method defined in \nPhln\n).\n\n\nIt exposes two methods:\n1. \ncallFn(...$args)\n - calls function from a given context and returns it's result\n2. \ngetResolvedFn()\n - returns \"reference\" for function from a given context\n\n\nIt's requires to define \ngetTestedFn()\n method which should return \"reference\" to main function.\n\n\nDue to some restrictions in PHPUnit \nTestBundleListener\n will generate, slightly odd, report:\n\n\n...............................................................  63 / 250 ( 25%)\n............................................................... 126 / 250 ( 50%)\n............................................................... 189 / 250 ( 75%)\n.............................................................   250 / 250 (100%).. 252 / 250 (100%)\n............................................................... 315 / 250 (126%)\n............................................................... 378 / 250 (151%)\n............................................................... 441 / 250 (176%)\n............................................\n\n\n\n\nStructure of PHPDoc\n\n\nEvery main function should have PHPDoc. Later it will be used to generate package documentation files.\n\n\nIt should contain summary (title), \n@phlnSignature\n and \n@phlnCategory\n tags.\nDescription and \n@example\n tag are optional, yet I suggest strongly to provide \n@example\n\n\n@phlnSignature\n is \nHindley\u2013Milner type system\n definition", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#function-file", 
            "text": "Function should be defined in it's own file. In fact this file stores definition of two functions:   main function  (the one which is exprted) - a simple wrapper for curried version of  \ud835\udc53 function  \ud835\udc53 function  - holds the main logic and typehinting of the function.   This structure is maintened only for  \ud835\udc53 function  with arity   1.  For example, definition of  sum()  could look like this:  function sum(int $a = null, int $b = null)\n{\n    return curryN(2, \ud835\udc53sum, func_get_args());\n}\n\nfunction \ud835\udc53sum(int $a, int $b): int\n{\n    return $a + $b;\n}  Example has missing function constants. In such case there are also two defined constants:   main const  - points to the wrapper  \ud835\udc53 const  - points to  \ud835\udc53 function ; it's used mostly internally   const sum = '\\\\phln\\\\math\\\\sum';\nconst \ud835\udc53sum = '\\\\phln\\\\math\\\\\ud835\udc53sum';", 
            "title": "Function file"
        }, 
        {
            "location": "/internals/#adding-new-function-build-pipeline", 
            "text": "", 
            "title": "Adding new function - build pipeline"
        }, 
        {
            "location": "/internals/#creating-new-function", 
            "text": "First step is to create a new function. It can be done using  create:fn  command.  ./bin/console.php create:fn namespace fnName  This command will generate from template function with test case.\nName of the function has to be unique in scope of all  phln  functions.", 
            "title": "Creating new function"
        }, 
        {
            "location": "/internals/#generating-static-wrapper", 
            "text": "When function is done it should be added to  phln\\Phln  class.\nThis class is result of  create:bundle  command so I suggest to use it to add newly created function.  ./bin/console.php create:bundle", 
            "title": "Generating static wrapper"
        }, 
        {
            "location": "/internals/#generating-docs", 
            "text": "Some parts of docs are compiled from PHPDocs of functions defined in  phln\\Phln  class.\nTo compile new version of docs (once the class is created) use  create:docs  command.  ./bin/console.php create:docs", 
            "title": "Generating docs"
        }, 
        {
            "location": "/internals/#testing", 
            "text": "phln  uses PHPUnit to run tests.", 
            "title": "Testing"
        }, 
        {
            "location": "/internals/#about-phlnbuildphpunittestcase", 
            "text": "Phln\\Build\\PhpUnit\\TestCase  allows to run test case in two different \"contexts\". By default it runs tests using main function. Combined with  TestBundleListener  it will be executed once again with \"context\" of  phln\\Phln  class (test case will use appropriate method defined in  Phln ).  It exposes two methods:\n1.  callFn(...$args)  - calls function from a given context and returns it's result\n2.  getResolvedFn()  - returns \"reference\" for function from a given context  It's requires to define  getTestedFn()  method which should return \"reference\" to main function.  Due to some restrictions in PHPUnit  TestBundleListener  will generate, slightly odd, report:  ...............................................................  63 / 250 ( 25%)\n............................................................... 126 / 250 ( 50%)\n............................................................... 189 / 250 ( 75%)\n.............................................................   250 / 250 (100%).. 252 / 250 (100%)\n............................................................... 315 / 250 (126%)\n............................................................... 378 / 250 (151%)\n............................................................... 441 / 250 (176%)\n............................................", 
            "title": "About Phln\\Build\\PhpUnit\\TestCase"
        }, 
        {
            "location": "/internals/#structure-of-phpdoc", 
            "text": "Every main function should have PHPDoc. Later it will be used to generate package documentation files.  It should contain summary (title),  @phlnSignature  and  @phlnCategory  tags.\nDescription and  @example  tag are optional, yet I suggest strongly to provide  @example  @phlnSignature  is  Hindley\u2013Milner type system  definition", 
            "title": "Structure of PHPDoc"
        }, 
        {
            "location": "/functions/collection/", 
            "text": "all\n\n\n(a -\n Boolean) -\n [a] -\n Boolean\n\n\nReturns \ntrue\n if all elements of array match the predicate, \nfalse\n otherwise.\n\n\n$onlyTwos = P::all(P::equals(2));\n$onlyTwos([1, 2, 2]); // false\n\n\n\n\nany\n\n\n(a -\n Boolean) -\n [a] -\n Boolean\n\n\nReturns \ntrue\n if at least one of array elements match the predicate, \nfalse\n otherwise.\n\n\n$hasTwos = P::any(P::equals(2));\n$hasTwos([1, 2, 3, 4]); // true\n\n\n\n\nappend\n\n\na -\n [a] -\n [a]\n\n\nString -\n String -\n String\n\n\nReturns a new list containing the contents of the given list or string, followed by the given element.\n\n\nP::append(3, [1, 2]); // [1, 2, 3]\nP::append([3], [1, 2]); // [1, 2, [3]]\nP::append('foo', 'bar'); // 'barfoo'\n\n\n\n\nchunk\n\n\nNumber -\n [a] -\n [[a]]\n\n\nNumber -\n String -\n [String]\n\n\nChunks an array or string into arrays with \nsize\n elements.\n\n\nThe last chunk may contain less than \nsize\n elements.\n\n\nP::chunk(2, [1, 2, 3, 4]); // [[1, 2], [3, 4]]\nP::chunk(2, 'hello'); // ['he', 'll', 'o']\n\n\n\n\ncollapse\n\n\n[[*], [*]] -\n [*, *]\n\n\nFlattens array elements by one level\n\n\nconcat\n\n\n[a] -\n [a] -\n [a]\n\n\nString -\n String -\n String\n\n\nReturns the result of concatenating the given lists or strings.\n\n\nNote: \nP::concat\n expects both arguments to be of the same type, otherwise it will throw an exception.\n\n\nP::concat([1, 2], [3]); // [1, 2, 3]\nP::concat('foo', 'bar'); // 'foobar'\n\n\n\n\ncontains\n\n\na -\n [a] -\n Boolean\n\n\nString -\n String -\n Boolean\n\n\nReturns \ntrue\n if the specified value is equal, \nP::equals\n terms,\nto at least one element of the given collection; \nfalse\n otherwise.\n\n\nP::contains(1, [1, 2, 3]); // true\nP::contains('foo', 'foobar'); // true\n\n\n\n\nfilter\n\n\n(a -\n Boolean) -\n [a] -\n Boolean\n\n\nFilters elements of an array using a callback function\n\n\nP::filter(equals(1), [1, 2, 3]); // [1]\n\n\n\n\nfind\n\n\n(a -\n Boolean) -\n [a] -\n a\n\n\nReturns the first element of the list which matches the predicate,\nor \nnull\n if no element matches.\n\n\n$xs = [['a' =\n 1], ['a' =\n 2], ['a' =\n 3]];\nP::find(equals(['a' =\n 1]), $xs); // ['a' =\n 1]\n\n\n\n\nflatMap\n\n\n(a -\n b) -\n [a] -\n [b]\n\n\nMaps a function over list and concatenates results\n\n\n$duplicateElements = P::flatMap(function ($i) {\n    return [$i, $i];\n});\n\n$duplicateElements([1, 2]); // [1, 1, 2, 2]\n\n\n\n\nfromPairs\n\n\n[[k, v]] -\n {k: v}\n\n\nCreates a new key =\n value object from list of pairs.\n\n\nP::fromPairs([['foo', 1], ['bar', 2]]); // [ 'foo' =\n 1, 'bar' =\n 2 ]\n\n\n\n\nhead\n\n\n[a] -\n a | Null\n\n\nString -\n String\n\n\nReturns the first element of a given list or string\n\n\nP::head([1, 2, 3]); // 1\nP::head([]); // null\nP::head('foo'); // 'f'\nP::head('f'); // ''\n\n\n\n\ninit\n\n\n[a] -\n [a]\n\n\nString -\n String\n\n\nReturns all but the last element of the given array or string.\n\n\nP::init([1, 2, 3]); // [1, 2]\nP::init([1, 2]); // [1]\nP::init([1]); // []\nP::init([]); // []\n\nP::init('lorem'); // 'lore'\nP::init('lo'); // 'l'\nP::init('l'); // ''\nP::init(''); // ''\n\n\n\n\njoin\n\n\nString -\n [a] -\n String\n\n\nReturns a string made by inserting the separator between each element and concatenating all the elements into a single string.\n\n\n$spacer = P::join(' ');\n$spacer([1, 2, 3]); // '1 2 3'\n\n\n\n\nlast\n\n\n[a] -\n a\n\n\nString -\n String\n\n\nReturns the last element of the given list or string.\n\n\nP::last([1, 2, 3]); // 3\nP::last([]); // null\nP::last('foo'); // 'o'\nP::last('f'); // 'f'\n\n\n\n\nlength\n\n\n[a] -\n Number\n\n\nString -\n Number\n\n\nReturns the number of elements in the array or string\n\n\nP::length('lorem'); // 5\n\n\n\n\nmap\n\n\n(a -\n b) -\n [a] -\n [b]\n\n\nApplies the callback to the elements of the given arrays\n\n\nmapIndexed\n\n\n((a, i) -\n b) -\n [a] -\n [b]\n\n\nApplies the callback to the elements of the given arrays\n\n\nCallback will receive index of iterated value as a second argument.\n\n\nnone\n\n\n(a -\n Boolean) -\n [a] -\n Boolean\n\n\nReturns \ntrue\n if no elements of the list match the predicate, \nfalse\n otherwise.\n\n\n$isEven = function ($i) {\n    return $i % 2 === 0;\n};\n\nP::none($isEven, [1, 3, 5]); // true\nP::none($isEven, [1, 3, 5, 6]); // false\n\n\n\n\nnth\n\n\nNumber -\n [a] -\n a | Null\n\n\nReturns the nth element of the given list or string.\n\n\nIf n is negative the element at index length - n is returned.\n\n\nP::nth(1, [1, 2, 3]); // 2\nP::nth(-1, [1, 2, 3]); // 3\n\n\n\n\npartition\n\n\n(a -\n Bool) -\n [a] -\n [[a], [a]]\n\n\nTakes a predicate and a collection and returns the pair of filterable objects of the same type of elements which do and do not satisfy, the predicate, respectively.\n\n\nP::partition(\n    P::contains('foo'),\n    ['foo bar', 'bar', 'foo']\n); // [['foo bar', 'foo'], ['bar']]\n\n\n\n\npluck\n\n\nk -\n [{k: v}] -\n v\n\n\nReturns a new list by plucking the same named property off all objects in the list supplied.\n\n\n$list = [['a' =\n 1], ['a' =\n 2]];\nP::pluck('a', $list); // [1, 2]\n\n\n\n\nprepend\n\n\na -\n [a] -\n [a]\n\n\nString -\n String -\n String\n\n\nReturns a new collection with the given element at the front, followed by the contents of the list or string.\n\n\nP::prepend(3, [1, 2]); // [3, 1, 2]\nP::prepend([3], [1, 2]); // [[3], 1, 2]\nP::prepend('foo', 'bar'); // [[3], 1, 2]\n\n\n\n\nrange\n\n\nInteger a =\n a -\n a -\n [a]\n\n\nReturns a list of numbers from \nfrom\n (inclusive) to \nto\n (exclusive).\n\n\nP::range(0, 3); // [0, 1, 2]\n\n\n\n\nreduce\n\n\n((a, b) -\n a) -\n a -\n [b] -\n a\n\n\nReturns a single item by iterating through the list, successively calling the iterator function and passing it an accumulator value and the current value from the array, and then passing the result to the next call.\n\n\nThe iterator function receives two values: (\nacc\n, \nvalue\n).\n\n\nP::reduce(P::subtract, 0, [1, 2, 3, 4]);\n// ((((0 - 1) - 2) - 3) - 4) =\n -10\n\n\n\n\nreject\n\n\n(a -\n Boolean) -\n [a] -\n [a]\n\n\nThe negation of \nfilter\n.\n\n\n$isOdd = function ($i) {\n    return $i % 2 === 1;\n};\nP::reject($isOdd, [1, 2, 3, 4]); // [2, 4]\n\n\n\n\nreverse\n\n\n[a] -\n [a]\n\n\nString -\n String\n\n\nReturns a new list or string with the elements in reverse order.\n\n\nP::reverse([1, 2, 3]); // [3, 2, 1]\nP::reverse('foo'); // 'oof'\n\n\n\n\nslice\n\n\nInteger -\n Integer -\n [a] -\n [a]\n\n\nInteger -\n Integer -\n String -\n String\n\n\nExtracts a slice of the array or string\n\n\n$takeTwo = P::slice(0, 2);\n$takeTwo([1, 2, 3]); // [1, 2]\n\n\n\n\nsort\n\n\n((a, a) -\n Number) -\n [a] -\n [a]\n\n\nReturns a copy of the list, sorted according to the comparator function, which should accept two values at a time and return a negative number if the first value is smaller, a positive number if it's larger, and zero if they are equal.\n\n\n$diff = function ($a, $b) {\n    return $a - $b;\n};\n\nP::sort($diff, [3, 2, 1]); // [1, 2, 3]\n\n\n\n\nsortBy\n\n\n(a -\n b) -\n [a] -\n [a]\n\n\nSorts the list according to the supplied function.\n\n\n$alice = ['name' =\n 'alice'];\n$bob = ['name' =\n 'bob'];\n$clara = ['name' =\n 'clara'];\n$people = [$bob, $clara, $alice];\n\nP::soryBy(P::prop('name'), $people); // [$alice, $bob, $clara]\n\n\n\n\ntail\n\n\n[a] -\n [a]\n\n\nString -\n String\n\n\nReturns all but the first element of the given array or string\n\n\nP::tail([1, 2, 3]); // [2, 3]\nP::tail([1]); // []\nP::tail([]); // []\nP::tail('lorem'); // 'orem'\nP::tail('l'); // ''\nP::tail(''); // ''\n\n\n\n\nunique\n\n\n[a] -\n [a]\n\n\nReturns a new list containing only one copy of each element in the original list. Strict comparision is used to determine equality.\n\n\nP::unique([3, 2, 1, 1, 3, 2]); // [3, 2, 1]", 
            "title": "Collection"
        }, 
        {
            "location": "/functions/collection/#all", 
            "text": "(a -  Boolean) -  [a] -  Boolean  Returns  true  if all elements of array match the predicate,  false  otherwise.  $onlyTwos = P::all(P::equals(2));\n$onlyTwos([1, 2, 2]); // false", 
            "title": "all"
        }, 
        {
            "location": "/functions/collection/#any", 
            "text": "(a -  Boolean) -  [a] -  Boolean  Returns  true  if at least one of array elements match the predicate,  false  otherwise.  $hasTwos = P::any(P::equals(2));\n$hasTwos([1, 2, 3, 4]); // true", 
            "title": "any"
        }, 
        {
            "location": "/functions/collection/#append", 
            "text": "a -  [a] -  [a]  String -  String -  String  Returns a new list containing the contents of the given list or string, followed by the given element.  P::append(3, [1, 2]); // [1, 2, 3]\nP::append([3], [1, 2]); // [1, 2, [3]]\nP::append('foo', 'bar'); // 'barfoo'", 
            "title": "append"
        }, 
        {
            "location": "/functions/collection/#chunk", 
            "text": "Number -  [a] -  [[a]]  Number -  String -  [String]  Chunks an array or string into arrays with  size  elements.  The last chunk may contain less than  size  elements.  P::chunk(2, [1, 2, 3, 4]); // [[1, 2], [3, 4]]\nP::chunk(2, 'hello'); // ['he', 'll', 'o']", 
            "title": "chunk"
        }, 
        {
            "location": "/functions/collection/#collapse", 
            "text": "[[*], [*]] -  [*, *]  Flattens array elements by one level", 
            "title": "collapse"
        }, 
        {
            "location": "/functions/collection/#concat", 
            "text": "[a] -  [a] -  [a]  String -  String -  String  Returns the result of concatenating the given lists or strings.  Note:  P::concat  expects both arguments to be of the same type, otherwise it will throw an exception.  P::concat([1, 2], [3]); // [1, 2, 3]\nP::concat('foo', 'bar'); // 'foobar'", 
            "title": "concat"
        }, 
        {
            "location": "/functions/collection/#contains", 
            "text": "a -  [a] -  Boolean  String -  String -  Boolean  Returns  true  if the specified value is equal,  P::equals  terms,\nto at least one element of the given collection;  false  otherwise.  P::contains(1, [1, 2, 3]); // true\nP::contains('foo', 'foobar'); // true", 
            "title": "contains"
        }, 
        {
            "location": "/functions/collection/#filter", 
            "text": "(a -  Boolean) -  [a] -  Boolean  Filters elements of an array using a callback function  P::filter(equals(1), [1, 2, 3]); // [1]", 
            "title": "filter"
        }, 
        {
            "location": "/functions/collection/#find", 
            "text": "(a -  Boolean) -  [a] -  a  Returns the first element of the list which matches the predicate,\nor  null  if no element matches.  $xs = [['a' =  1], ['a' =  2], ['a' =  3]];\nP::find(equals(['a' =  1]), $xs); // ['a' =  1]", 
            "title": "find"
        }, 
        {
            "location": "/functions/collection/#flatmap", 
            "text": "(a -  b) -  [a] -  [b]  Maps a function over list and concatenates results  $duplicateElements = P::flatMap(function ($i) {\n    return [$i, $i];\n});\n\n$duplicateElements([1, 2]); // [1, 1, 2, 2]", 
            "title": "flatMap"
        }, 
        {
            "location": "/functions/collection/#frompairs", 
            "text": "[[k, v]] -  {k: v}  Creates a new key =  value object from list of pairs.  P::fromPairs([['foo', 1], ['bar', 2]]); // [ 'foo' =  1, 'bar' =  2 ]", 
            "title": "fromPairs"
        }, 
        {
            "location": "/functions/collection/#head", 
            "text": "[a] -  a | Null  String -  String  Returns the first element of a given list or string  P::head([1, 2, 3]); // 1\nP::head([]); // null\nP::head('foo'); // 'f'\nP::head('f'); // ''", 
            "title": "head"
        }, 
        {
            "location": "/functions/collection/#init", 
            "text": "[a] -  [a]  String -  String  Returns all but the last element of the given array or string.  P::init([1, 2, 3]); // [1, 2]\nP::init([1, 2]); // [1]\nP::init([1]); // []\nP::init([]); // []\n\nP::init('lorem'); // 'lore'\nP::init('lo'); // 'l'\nP::init('l'); // ''\nP::init(''); // ''", 
            "title": "init"
        }, 
        {
            "location": "/functions/collection/#join", 
            "text": "String -  [a] -  String  Returns a string made by inserting the separator between each element and concatenating all the elements into a single string.  $spacer = P::join(' ');\n$spacer([1, 2, 3]); // '1 2 3'", 
            "title": "join"
        }, 
        {
            "location": "/functions/collection/#last", 
            "text": "[a] -  a  String -  String  Returns the last element of the given list or string.  P::last([1, 2, 3]); // 3\nP::last([]); // null\nP::last('foo'); // 'o'\nP::last('f'); // 'f'", 
            "title": "last"
        }, 
        {
            "location": "/functions/collection/#length", 
            "text": "[a] -  Number  String -  Number  Returns the number of elements in the array or string  P::length('lorem'); // 5", 
            "title": "length"
        }, 
        {
            "location": "/functions/collection/#map", 
            "text": "(a -  b) -  [a] -  [b]  Applies the callback to the elements of the given arrays", 
            "title": "map"
        }, 
        {
            "location": "/functions/collection/#mapindexed", 
            "text": "((a, i) -  b) -  [a] -  [b]  Applies the callback to the elements of the given arrays  Callback will receive index of iterated value as a second argument.", 
            "title": "mapIndexed"
        }, 
        {
            "location": "/functions/collection/#none", 
            "text": "(a -  Boolean) -  [a] -  Boolean  Returns  true  if no elements of the list match the predicate,  false  otherwise.  $isEven = function ($i) {\n    return $i % 2 === 0;\n};\n\nP::none($isEven, [1, 3, 5]); // true\nP::none($isEven, [1, 3, 5, 6]); // false", 
            "title": "none"
        }, 
        {
            "location": "/functions/collection/#nth", 
            "text": "Number -  [a] -  a | Null  Returns the nth element of the given list or string.  If n is negative the element at index length - n is returned.  P::nth(1, [1, 2, 3]); // 2\nP::nth(-1, [1, 2, 3]); // 3", 
            "title": "nth"
        }, 
        {
            "location": "/functions/collection/#partition", 
            "text": "(a -  Bool) -  [a] -  [[a], [a]]  Takes a predicate and a collection and returns the pair of filterable objects of the same type of elements which do and do not satisfy, the predicate, respectively.  P::partition(\n    P::contains('foo'),\n    ['foo bar', 'bar', 'foo']\n); // [['foo bar', 'foo'], ['bar']]", 
            "title": "partition"
        }, 
        {
            "location": "/functions/collection/#pluck", 
            "text": "k -  [{k: v}] -  v  Returns a new list by plucking the same named property off all objects in the list supplied.  $list = [['a' =  1], ['a' =  2]];\nP::pluck('a', $list); // [1, 2]", 
            "title": "pluck"
        }, 
        {
            "location": "/functions/collection/#prepend", 
            "text": "a -  [a] -  [a]  String -  String -  String  Returns a new collection with the given element at the front, followed by the contents of the list or string.  P::prepend(3, [1, 2]); // [3, 1, 2]\nP::prepend([3], [1, 2]); // [[3], 1, 2]\nP::prepend('foo', 'bar'); // [[3], 1, 2]", 
            "title": "prepend"
        }, 
        {
            "location": "/functions/collection/#range", 
            "text": "Integer a =  a -  a -  [a]  Returns a list of numbers from  from  (inclusive) to  to  (exclusive).  P::range(0, 3); // [0, 1, 2]", 
            "title": "range"
        }, 
        {
            "location": "/functions/collection/#reduce", 
            "text": "((a, b) -  a) -  a -  [b] -  a  Returns a single item by iterating through the list, successively calling the iterator function and passing it an accumulator value and the current value from the array, and then passing the result to the next call.  The iterator function receives two values: ( acc ,  value ).  P::reduce(P::subtract, 0, [1, 2, 3, 4]);\n// ((((0 - 1) - 2) - 3) - 4) =  -10", 
            "title": "reduce"
        }, 
        {
            "location": "/functions/collection/#reject", 
            "text": "(a -  Boolean) -  [a] -  [a]  The negation of  filter .  $isOdd = function ($i) {\n    return $i % 2 === 1;\n};\nP::reject($isOdd, [1, 2, 3, 4]); // [2, 4]", 
            "title": "reject"
        }, 
        {
            "location": "/functions/collection/#reverse", 
            "text": "[a] -  [a]  String -  String  Returns a new list or string with the elements in reverse order.  P::reverse([1, 2, 3]); // [3, 2, 1]\nP::reverse('foo'); // 'oof'", 
            "title": "reverse"
        }, 
        {
            "location": "/functions/collection/#slice", 
            "text": "Integer -  Integer -  [a] -  [a]  Integer -  Integer -  String -  String  Extracts a slice of the array or string  $takeTwo = P::slice(0, 2);\n$takeTwo([1, 2, 3]); // [1, 2]", 
            "title": "slice"
        }, 
        {
            "location": "/functions/collection/#sort", 
            "text": "((a, a) -  Number) -  [a] -  [a]  Returns a copy of the list, sorted according to the comparator function, which should accept two values at a time and return a negative number if the first value is smaller, a positive number if it's larger, and zero if they are equal.  $diff = function ($a, $b) {\n    return $a - $b;\n};\n\nP::sort($diff, [3, 2, 1]); // [1, 2, 3]", 
            "title": "sort"
        }, 
        {
            "location": "/functions/collection/#sortby", 
            "text": "(a -  b) -  [a] -  [a]  Sorts the list according to the supplied function.  $alice = ['name' =  'alice'];\n$bob = ['name' =  'bob'];\n$clara = ['name' =  'clara'];\n$people = [$bob, $clara, $alice];\n\nP::soryBy(P::prop('name'), $people); // [$alice, $bob, $clara]", 
            "title": "sortBy"
        }, 
        {
            "location": "/functions/collection/#tail", 
            "text": "[a] -  [a]  String -  String  Returns all but the first element of the given array or string  P::tail([1, 2, 3]); // [2, 3]\nP::tail([1]); // []\nP::tail([]); // []\nP::tail('lorem'); // 'orem'\nP::tail('l'); // ''\nP::tail(''); // ''", 
            "title": "tail"
        }, 
        {
            "location": "/functions/collection/#unique", 
            "text": "[a] -  [a]  Returns a new list containing only one copy of each element in the original list. Strict comparision is used to determine equality.  P::unique([3, 2, 1, 1, 3, 2]); // [3, 2, 1]", 
            "title": "unique"
        }, 
        {
            "location": "/functions/function/", 
            "text": "F\n\n\n* -\n Boolean\n\n\nA function that always returns \nfalse\n. Any passed in parameters are ignored.\n\n\nT\n\n\n* -\n Boolean\n\n\nA function that always returns \ntrue\n. Any passed in parameters are ignored.\n\n\nalways\n\n\na -\n (* -\n a)\n\n\nReturns a function that always returns the given value.\n\n\nFor non-primitives the value returned is a reference to the original value.\n\n\n$foo = P::always('foo');\n$foo(); // 'foo'\n\n\n\n\napply\n\n\n(*... -\n a) -\n [*] -\n a\n\n\nApplies function \nfn\n to the argument list. This is useful for creating a fixed-arity function from a variadic function.\n\n\nP::apply(P::sum, [1, 2]); // 3\n\n\n\n\narity\n\n\n(*... -\n *) -\n Number\n\n\nTakes a function and returns its arity.\n\n\nP::arity('var_dump'); // 1\n\n\n\n\ncompose\n\n\n[((a, b, ..., n) -\n o), (o -\n p), ..., (x -\n y), (y -\n z)] -\n (a, b, ..., n) -\n z)\n\n\nPerforms left-to-right function composition.\n\n\nThe leftmost function may have any arity; the remaining functions must be unary.\n\n\nNote\n: The result of pipe is not automatically curried.\n\n\ncurry\n\n\n(* \u2192 a) \u2192 (* \u2192 a)\n\n\nReturns a curried equivalent of the provided function.\n\n\nCurried function doesn't require providing arguments one at a time.\nIf \nf\n is a ternary function and \ng\n is \nP::curry(f)\n, the following are equivalent.\n     * g(1)(2)(3)\n     * g(1)(2, 3)\n     * g(1, 2)(3)\n     * g(1, 2, 3)\n\n\ncurryN\n\n\nNumber -\n (* \u2192 a) \u2192 (* \u2192 a)\n\n\nReturns a curried equivalent of the provided function, with the specified arity.\n\n\nCurried function doesn't require providing arguments one at a time.\nIf \nf\n is a ternary function and \ng\n is \nP::curryN(3, f)\n, the following are equivalent.\n     * g(1)(2)(3)\n     * g(1)(2, 3)\n     * g(1, 2)(3)\n     * g(1, 2, 3)\n\n\nidentity\n\n\na -\n a\n\n\nA function that does nothing but return the parameter supplied to it. Good as a default or placeholder function.\n\n\nP::identity(1) === 1; // 'true'\n\n\n\n\ninvoker\n\n\nInt -\n String -\n (a -\n b -\n c -\n ... -\n n -\n Object -\n *)\n\n\nTurns a named method with a specified arity into a function that can be called directly supplied with arguments and a target object.\n\n\nThe returned function is curried and accepts \narity + 1\n parameters where the final parameter is the target object.\n\n\n$greeter = new class ()\n{\n    public function hello($name, $lastname)\n    {\n        return \nHello, {$name} {$lastname}!\n;\n    }\n};\n\n$helloToJon = P::invoker(2, 'hello')('Jon');\n$helloToJon('Snow'); // 'Hello, Jon Snow!'\n\n\n\n\nnegate\n\n\n(*... -\n *) -\n (*... -\n Boolean)\n\n\nCreates a function that negates the result of the predicate.\n\n\n$isEven = function ($i) {\n    return $i % 2 === 0;\n};\n\nP::filter(P::negate($isEven), [1, 2, 3, 4, 5, 6]); // [1, 3, 5]\n\n\n\n\nof\n\n\na -\n [a]\n\n\nReturns a singleton array containing the value provided.\n\n\nP::of(null); // [null]\nP::of('a'); // ['a']\n\n\n\n\nonce\n\n\n(a... -\n b) -\n (a... -\n b)\n\n\nAccepts a function \nfn\n and returns a function that guards invocation of \nfn\n such that \nfn\n can only ever be called once, no matter how many times the returned function is invoked. The first value calculated is returned in subsequent invocations.\n\n\n$f = P::once('\\rand');\n$f(1, 100); // 4\n$f(1, 100); // 4\n$f(1, 100); // 4\n\n\n\n\npartial\n\n\n((a, b, c, ..., n) -\n x) -\n [a, b, c, ...] -\n ((d, e, f, ..., n) -\n x)\n\n\nTakes a function \nf\n and a list of arguments, and returns a function \ng\n.\n\n\nWhen applied, \ng\n returns the result of applying \nf\n to the arguments provided initially followed by the arguments provided to \ng\n.\n\n\nSpecial placeholder value \nP::__\n may be used to specify \"gaps\", allowing partial application of any combination of arguments, regardless of their positions.\n\n\n$subtractFive = P::partial(P::subtract, [P::__, 5]);\n$subtractFive(10); // 5\n\n\n\n\npartialRight\n\n\n((a, b, c, d, ..., n) -\n x) -\n [d, ..., n] -\n ((a, b, c) -\n x)\n\n\nTakes a function \nf\n and a list of arguments, and returns a function \ng\n. When applied, \ng\n returns the result of applying \nf\n to the arguments provided initially followed by the arguments provided to \ng\n.\n\n\n$hello = function ($salutations, $name, $lastname) {\n    return \n{$salutations}, {$name} {$lastname}\n;\n};\n\n$f = P::partialRight($hello, ['Jon', 'Stark']);\n$f('Hello'); // 'Hello, Jon Stark'\n\n\n\n\npipe\n\n\n[((a, b, ..., n) -\n o), (o -\n p), ..., (x -\n y), (y -\n z)] -\n (a, b, ..., n) -\n z)\n\n\nPerforms left-to-right function composition.\n\n\nThe leftmost function may have any arity; the remaining functions must be unary.\n\n\nNote\n: The result of pipe is not automatically curried.\n\n\nswap\n\n\n(a -\n b -\n c -\n ... -\n z) -\n (b -\n a -\n c -\n ... -\n z)\n\n\nReturns a new function much like the supplied one, except that the first two arguments' order is reversed.\n\n\n$serialize = function ($a, $b) {\n    return \na:{$a},b:{$b}\n;\n};\nP::swap($serialize)(2, 1); // 'a:1,b:2'\n\n\n\n\ntap\n\n\n(a -\n *) -\n a -\n a\n\n\nRuns the given function with the supplied object, then returns the object.\n\n\n$dump = P::tap('var_dump');\n$dump('foo'); // var_dumps('foo'); returns 'foo'\n\n\n\n\nthrowException\n\n\n(String, [*]) -\n (*... -\n Null)\n\n\nReturns callback which throws given exception.\n\n\nNote:\n exceptions are considered as side-efects. Use it with caution.\n\n\n$break = P::throwException(\\LogicException::class);\n$break(); // -\n throw new \\LogicException()\n\n\n\n\nunapply\n\n\n([*...] -\n a) -\n (*... -\n a)\n\n\nTakes a function \nfn\n, which takes a single array argument, and returns a function which:\n\n takes any number of positional arguments;\n\n passes these arguments to \nfn\n as an array and returns the result\n\n\nIn other words, \nP::unapply\n derives a variadic function from a function which takes an array. \nP::unapply\n is the inverse of \nP::apply\n.\n\n\nP::unapply('\\\\json_encode')(1, 2, 3); // [1,2,3]", 
            "title": "Function"
        }, 
        {
            "location": "/functions/function/#f", 
            "text": "* -  Boolean  A function that always returns  false . Any passed in parameters are ignored.", 
            "title": "F"
        }, 
        {
            "location": "/functions/function/#t", 
            "text": "* -  Boolean  A function that always returns  true . Any passed in parameters are ignored.", 
            "title": "T"
        }, 
        {
            "location": "/functions/function/#always", 
            "text": "a -  (* -  a)  Returns a function that always returns the given value.  For non-primitives the value returned is a reference to the original value.  $foo = P::always('foo');\n$foo(); // 'foo'", 
            "title": "always"
        }, 
        {
            "location": "/functions/function/#apply", 
            "text": "(*... -  a) -  [*] -  a  Applies function  fn  to the argument list. This is useful for creating a fixed-arity function from a variadic function.  P::apply(P::sum, [1, 2]); // 3", 
            "title": "apply"
        }, 
        {
            "location": "/functions/function/#arity", 
            "text": "(*... -  *) -  Number  Takes a function and returns its arity.  P::arity('var_dump'); // 1", 
            "title": "arity"
        }, 
        {
            "location": "/functions/function/#compose", 
            "text": "[((a, b, ..., n) -  o), (o -  p), ..., (x -  y), (y -  z)] -  (a, b, ..., n) -  z)  Performs left-to-right function composition.  The leftmost function may have any arity; the remaining functions must be unary.  Note : The result of pipe is not automatically curried.", 
            "title": "compose"
        }, 
        {
            "location": "/functions/function/#curry", 
            "text": "(* \u2192 a) \u2192 (* \u2192 a)  Returns a curried equivalent of the provided function.  Curried function doesn't require providing arguments one at a time.\nIf  f  is a ternary function and  g  is  P::curry(f) , the following are equivalent.\n     * g(1)(2)(3)\n     * g(1)(2, 3)\n     * g(1, 2)(3)\n     * g(1, 2, 3)", 
            "title": "curry"
        }, 
        {
            "location": "/functions/function/#curryn", 
            "text": "Number -  (* \u2192 a) \u2192 (* \u2192 a)  Returns a curried equivalent of the provided function, with the specified arity.  Curried function doesn't require providing arguments one at a time.\nIf  f  is a ternary function and  g  is  P::curryN(3, f) , the following are equivalent.\n     * g(1)(2)(3)\n     * g(1)(2, 3)\n     * g(1, 2)(3)\n     * g(1, 2, 3)", 
            "title": "curryN"
        }, 
        {
            "location": "/functions/function/#identity", 
            "text": "a -  a  A function that does nothing but return the parameter supplied to it. Good as a default or placeholder function.  P::identity(1) === 1; // 'true'", 
            "title": "identity"
        }, 
        {
            "location": "/functions/function/#invoker", 
            "text": "Int -  String -  (a -  b -  c -  ... -  n -  Object -  *)  Turns a named method with a specified arity into a function that can be called directly supplied with arguments and a target object.  The returned function is curried and accepts  arity + 1  parameters where the final parameter is the target object.  $greeter = new class ()\n{\n    public function hello($name, $lastname)\n    {\n        return  Hello, {$name} {$lastname}! ;\n    }\n};\n\n$helloToJon = P::invoker(2, 'hello')('Jon');\n$helloToJon('Snow'); // 'Hello, Jon Snow!'", 
            "title": "invoker"
        }, 
        {
            "location": "/functions/function/#negate", 
            "text": "(*... -  *) -  (*... -  Boolean)  Creates a function that negates the result of the predicate.  $isEven = function ($i) {\n    return $i % 2 === 0;\n};\n\nP::filter(P::negate($isEven), [1, 2, 3, 4, 5, 6]); // [1, 3, 5]", 
            "title": "negate"
        }, 
        {
            "location": "/functions/function/#of", 
            "text": "a -  [a]  Returns a singleton array containing the value provided.  P::of(null); // [null]\nP::of('a'); // ['a']", 
            "title": "of"
        }, 
        {
            "location": "/functions/function/#once", 
            "text": "(a... -  b) -  (a... -  b)  Accepts a function  fn  and returns a function that guards invocation of  fn  such that  fn  can only ever be called once, no matter how many times the returned function is invoked. The first value calculated is returned in subsequent invocations.  $f = P::once('\\rand');\n$f(1, 100); // 4\n$f(1, 100); // 4\n$f(1, 100); // 4", 
            "title": "once"
        }, 
        {
            "location": "/functions/function/#partial", 
            "text": "((a, b, c, ..., n) -  x) -  [a, b, c, ...] -  ((d, e, f, ..., n) -  x)  Takes a function  f  and a list of arguments, and returns a function  g .  When applied,  g  returns the result of applying  f  to the arguments provided initially followed by the arguments provided to  g .  Special placeholder value  P::__  may be used to specify \"gaps\", allowing partial application of any combination of arguments, regardless of their positions.  $subtractFive = P::partial(P::subtract, [P::__, 5]);\n$subtractFive(10); // 5", 
            "title": "partial"
        }, 
        {
            "location": "/functions/function/#partialright", 
            "text": "((a, b, c, d, ..., n) -  x) -  [d, ..., n] -  ((a, b, c) -  x)  Takes a function  f  and a list of arguments, and returns a function  g . When applied,  g  returns the result of applying  f  to the arguments provided initially followed by the arguments provided to  g .  $hello = function ($salutations, $name, $lastname) {\n    return  {$salutations}, {$name} {$lastname} ;\n};\n\n$f = P::partialRight($hello, ['Jon', 'Stark']);\n$f('Hello'); // 'Hello, Jon Stark'", 
            "title": "partialRight"
        }, 
        {
            "location": "/functions/function/#pipe", 
            "text": "[((a, b, ..., n) -  o), (o -  p), ..., (x -  y), (y -  z)] -  (a, b, ..., n) -  z)  Performs left-to-right function composition.  The leftmost function may have any arity; the remaining functions must be unary.  Note : The result of pipe is not automatically curried.", 
            "title": "pipe"
        }, 
        {
            "location": "/functions/function/#swap", 
            "text": "(a -  b -  c -  ... -  z) -  (b -  a -  c -  ... -  z)  Returns a new function much like the supplied one, except that the first two arguments' order is reversed.  $serialize = function ($a, $b) {\n    return  a:{$a},b:{$b} ;\n};\nP::swap($serialize)(2, 1); // 'a:1,b:2'", 
            "title": "swap"
        }, 
        {
            "location": "/functions/function/#tap", 
            "text": "(a -  *) -  a -  a  Runs the given function with the supplied object, then returns the object.  $dump = P::tap('var_dump');\n$dump('foo'); // var_dumps('foo'); returns 'foo'", 
            "title": "tap"
        }, 
        {
            "location": "/functions/function/#throwexception", 
            "text": "(String, [*]) -  (*... -  Null)  Returns callback which throws given exception.  Note:  exceptions are considered as side-efects. Use it with caution.  $break = P::throwException(\\LogicException::class);\n$break(); // -  throw new \\LogicException()", 
            "title": "throwException"
        }, 
        {
            "location": "/functions/function/#unapply", 
            "text": "([*...] -  a) -  (*... -  a)  Takes a function  fn , which takes a single array argument, and returns a function which:  takes any number of positional arguments;  passes these arguments to  fn  as an array and returns the result  In other words,  P::unapply  derives a variadic function from a function which takes an array.  P::unapply  is the inverse of  P::apply .  P::unapply('\\\\json_encode')(1, 2, 3); // [1,2,3]", 
            "title": "unapply"
        }, 
        {
            "location": "/functions/logic/", 
            "text": "allPass\n\n\n[(*... -\n Boolean) -\n *... -\n Boolean\n\n\nTakes a list of predicates and returns a predicate that returns \ntrue\n for a given list of arguments if every one of the provided predicates is satisfied by those arguments.\n\n\nThe function returned is a curried function whose arity matches that of the highest-arity predicate.\n\n\n$ace = P::propEq('rank', 'A');\n$spades = P::propEq('suit', '\u2660\ufe0e');\n$aceOfSpades = P::allPass([$ace, $spades]);\n$aceOfSpades(['rank' =\n 'A', 'suit' =\n '\u2660\ufe0e']); // true\n\n\n\n\nboth\n\n\n(*... -\n Boolean) -\n (*... -\n Boolean) -\n (*... -\n Boolean)\n\n\nBoolean -\n Boolean -\n Boolean\n\n\nReturns \ntrue\n when both of two provided values are truthy.\n\n\nThis function is polymorphic and supports two cases:\n1. when both values are predicates it will return wrapper function which call to the two functions in an \n operation, returning \ntrue\n if both of the functions will return truthy value.\n2. when both values are booleans it will return result of \n operation\n\n\n$gt10 = P::partial(P::gt, [P::__, 10]);\n$lt20 = P::partial(P::lt, [P::__, 20]);\n$f = P::both($gt10, $lt20);\n$f(12); // true\nP::both(true, false); // false\n\n\n\n\ncond\n\n\n[[(*\u2026 \u2192 Boolean),(*\u2026 \u2192 *)]] \u2192 (*\u2026 \u2192 *)\n\n\nReturns a function, \nfn\n, which encapsulates \nif/else\n, \nif/else\n, .\n\n\n.. logic. \nP::cond\n takes a list of [\npredicate\n, \ntransformer\n] pairs. All of the arguments to \nfn\n are applied to each of the \npredicates\n in turn until one returns a truth-y value, at which point \nfn\n returns the result of applying its arguments to the corresponding \ntransformer\n. If none of the \npredicates\n matches, \nfn\n returns null.\n\n\n$fn = P::cond([\n    [P::equals(0), P::always('water freezes at 0\u00b0C')],\n    [P::equals(100), P::always('water boils at 100\u00b0C')],\n    [P::T, function(temp) {\n        return 'nothing special happens at ' + temp + '\u00b0C';\n    }]\n]);\n\n$fn(0); //=\n 'water freezes at 0\u00b0C'\n$fn(50); //=\n 'nothing special happens at 50\u00b0C'\n$fn(100); //=\n 'water boils at 100\u00b0C'\n\n\n\n\ndefaultTo\n\n\na -\n b -\n b | a\n\n\nReturns the second argument if it is not \nnull\n; otherwise the first argument is returned.\n\n\nP::defaultTo(42, null); // 42\nP::defaultTo(42, 'life'); // 'life'\n\n\n\n\neither\n\n\n(*... -\n Boolean) -\n (*... -\n Boolean) -\n (*... -\n Boolean)\n\n\nBoolean -\n Boolean -\n Boolean\n\n\nReturns \ntrue\n when one of two provided values is truthy.\n\n\nThis function is polymorphic and supports two cases:\n1. when both values are predicates it will return wrapper function which call to the two functions in an \n||\n operation, returning \ntrue\n if at least one of the functions will return truthy value.\n2. when both values are booleans it will return result of \n||\n operation\n\n\n$lt10 = P::partial(P::lt, [P::__, 10]);\n$gt20 = P::partial(P::gt, [P::__, 20]);\n$f = P::either($lt10, $gt20);\n$f(12); // false\n$f(9); // true\n$f(21); // true\nP::either(true, false); // true\n\n\n\n\nifElse\n\n\n(*... -\n Boolean) -\n (*... -\n *) -\n (*... -\n *) -\n (*... -\n *)\n\n\nCreates a function that will process either the \nonTrue\n or the \nonFalse\n function depending upon the result of the condition predicate.\n\n\n$modulo15 = P::swap(P::modulo)(15);\n$fizzbuzz = P::ifElse(\n    P::compose(P::equals(0), $modulo15),\n    P::always('fizzbuzz'),\n    P::identity\n);\n\n$fizzbuzz(15); // 'fizzbuzz'\n$fizzbuzz(1); // 1\n\n\n\n\nisEmpty\n\n\na -\n Boolean\n\n\nReturns \ntrue\n if the given value is its type's empty value; \nfalse\n otherwise.\n\n\nNote\n unlike \n\\empty()\n this function will consider numbers, booleans and NULL as non-empty.\n\n\nP::isEmpty(''); // true\nP::isEmpty([]); // true\nP::isEmpty(new stdClass); // true\nP::isEmpty(0); // false\nP::isEmpty(null); // false\nP::isEmpty(false); // false\nP::isEmpty(true); // false\n\n\n\n\nnot\n\n\n* -\n Boolean\n\n\nA function that returns the \n!\n of its argument. It will return \ntrue\n when passed false-y value, and \nfalse\n when passed a truth-y one.\n\n\nP::not(0); // true\nP::not(true); // false", 
            "title": "Logic"
        }, 
        {
            "location": "/functions/logic/#allpass", 
            "text": "[(*... -  Boolean) -  *... -  Boolean  Takes a list of predicates and returns a predicate that returns  true  for a given list of arguments if every one of the provided predicates is satisfied by those arguments.  The function returned is a curried function whose arity matches that of the highest-arity predicate.  $ace = P::propEq('rank', 'A');\n$spades = P::propEq('suit', '\u2660\ufe0e');\n$aceOfSpades = P::allPass([$ace, $spades]);\n$aceOfSpades(['rank' =  'A', 'suit' =  '\u2660\ufe0e']); // true", 
            "title": "allPass"
        }, 
        {
            "location": "/functions/logic/#both", 
            "text": "(*... -  Boolean) -  (*... -  Boolean) -  (*... -  Boolean)  Boolean -  Boolean -  Boolean  Returns  true  when both of two provided values are truthy.  This function is polymorphic and supports two cases:\n1. when both values are predicates it will return wrapper function which call to the two functions in an   operation, returning  true  if both of the functions will return truthy value.\n2. when both values are booleans it will return result of   operation  $gt10 = P::partial(P::gt, [P::__, 10]);\n$lt20 = P::partial(P::lt, [P::__, 20]);\n$f = P::both($gt10, $lt20);\n$f(12); // true\nP::both(true, false); // false", 
            "title": "both"
        }, 
        {
            "location": "/functions/logic/#cond", 
            "text": "[[(*\u2026 \u2192 Boolean),(*\u2026 \u2192 *)]] \u2192 (*\u2026 \u2192 *)  Returns a function,  fn , which encapsulates  if/else ,  if/else , .  .. logic.  P::cond  takes a list of [ predicate ,  transformer ] pairs. All of the arguments to  fn  are applied to each of the  predicates  in turn until one returns a truth-y value, at which point  fn  returns the result of applying its arguments to the corresponding  transformer . If none of the  predicates  matches,  fn  returns null.  $fn = P::cond([\n    [P::equals(0), P::always('water freezes at 0\u00b0C')],\n    [P::equals(100), P::always('water boils at 100\u00b0C')],\n    [P::T, function(temp) {\n        return 'nothing special happens at ' + temp + '\u00b0C';\n    }]\n]);\n\n$fn(0); //=  'water freezes at 0\u00b0C'\n$fn(50); //=  'nothing special happens at 50\u00b0C'\n$fn(100); //=  'water boils at 100\u00b0C'", 
            "title": "cond"
        }, 
        {
            "location": "/functions/logic/#defaultto", 
            "text": "a -  b -  b | a  Returns the second argument if it is not  null ; otherwise the first argument is returned.  P::defaultTo(42, null); // 42\nP::defaultTo(42, 'life'); // 'life'", 
            "title": "defaultTo"
        }, 
        {
            "location": "/functions/logic/#either", 
            "text": "(*... -  Boolean) -  (*... -  Boolean) -  (*... -  Boolean)  Boolean -  Boolean -  Boolean  Returns  true  when one of two provided values is truthy.  This function is polymorphic and supports two cases:\n1. when both values are predicates it will return wrapper function which call to the two functions in an  ||  operation, returning  true  if at least one of the functions will return truthy value.\n2. when both values are booleans it will return result of  ||  operation  $lt10 = P::partial(P::lt, [P::__, 10]);\n$gt20 = P::partial(P::gt, [P::__, 20]);\n$f = P::either($lt10, $gt20);\n$f(12); // false\n$f(9); // true\n$f(21); // true\nP::either(true, false); // true", 
            "title": "either"
        }, 
        {
            "location": "/functions/logic/#ifelse", 
            "text": "(*... -  Boolean) -  (*... -  *) -  (*... -  *) -  (*... -  *)  Creates a function that will process either the  onTrue  or the  onFalse  function depending upon the result of the condition predicate.  $modulo15 = P::swap(P::modulo)(15);\n$fizzbuzz = P::ifElse(\n    P::compose(P::equals(0), $modulo15),\n    P::always('fizzbuzz'),\n    P::identity\n);\n\n$fizzbuzz(15); // 'fizzbuzz'\n$fizzbuzz(1); // 1", 
            "title": "ifElse"
        }, 
        {
            "location": "/functions/logic/#isempty", 
            "text": "a -  Boolean  Returns  true  if the given value is its type's empty value;  false  otherwise.  Note  unlike  \\empty()  this function will consider numbers, booleans and NULL as non-empty.  P::isEmpty(''); // true\nP::isEmpty([]); // true\nP::isEmpty(new stdClass); // true\nP::isEmpty(0); // false\nP::isEmpty(null); // false\nP::isEmpty(false); // false\nP::isEmpty(true); // false", 
            "title": "isEmpty"
        }, 
        {
            "location": "/functions/logic/#not", 
            "text": "* -  Boolean  A function that returns the  !  of its argument. It will return  true  when passed false-y value, and  false  when passed a truth-y one.  P::not(0); // true\nP::not(true); // false", 
            "title": "not"
        }, 
        {
            "location": "/functions/math/", 
            "text": "add\n\n\nNumber a =\n a -\n a -\n a\n\n\nAdd two values\n\n\ndec\n\n\nInt a =\n a -\n a\n\n\nDecrement its argument\n\n\ndivide\n\n\nNumber a =\n a -\n a -\n a\n\n\nDivide numbers. Equivalent of \na / b\n\n\ninc\n\n\nInt a =\n a -\n a\n\n\nIncrement its argument\n\n\nmean\n\n\nNumber a =\n [a] -\n a\n\n\nReturns the mean of the given list of numbers.\n\n\nP::mean([2, 7, 9]) // 6\n\n\n\n\nmedian\n\n\nNumber a =\n [a] -\n a\n\n\nReturns the median of the given list of numbers.\n\n\n\\\\phln\\\\math\\\\median([7, 2, 9]) // 7\n\\\\phln\\\\math\\\\median([7, 2, 10, 9]) // 8\n\n\n\n\nmodulo\n\n\nNumber a =\n a -\n a -\n a\n\n\nDivides the first parameter by the second and returns the remainder.\n\n\n\\\\phln\\\\math\\\\modulo(1, 2) // 1\n\n\n\n\nmultiply\n\n\nNumber a =\n a -\n a -\n a\n\n\nMultiplies two numbers\n\n\n$triple = P::multiply(3);\n$triple(7); // 21\n\n\n\n\nproduct\n\n\nNumber a =\n [a] -\n a\n\n\nMultiplies together all the elements of a list.\n\n\nP::product([2, 4, 6, 8, 100, 1]); // 38400\n\n\n\n\nsubtract\n\n\nNumber a =\n a -\n a -\n a\n\n\nSubtracts its second argument from its first argument.\n\n\n$complementaryAngle = P::subtract(90);\n$complementaryAngle(30); //=\n 60\n\n\n\n\nsum\n\n\n[Number] -\n Number\n\n\nAdds together all the elements of a list.\n\n\nP::sum([1, 2, 3, 4]); // 10", 
            "title": "Math"
        }, 
        {
            "location": "/functions/math/#add", 
            "text": "Number a =  a -  a -  a  Add two values", 
            "title": "add"
        }, 
        {
            "location": "/functions/math/#dec", 
            "text": "Int a =  a -  a  Decrement its argument", 
            "title": "dec"
        }, 
        {
            "location": "/functions/math/#divide", 
            "text": "Number a =  a -  a -  a  Divide numbers. Equivalent of  a / b", 
            "title": "divide"
        }, 
        {
            "location": "/functions/math/#inc", 
            "text": "Int a =  a -  a  Increment its argument", 
            "title": "inc"
        }, 
        {
            "location": "/functions/math/#mean", 
            "text": "Number a =  [a] -  a  Returns the mean of the given list of numbers.  P::mean([2, 7, 9]) // 6", 
            "title": "mean"
        }, 
        {
            "location": "/functions/math/#median", 
            "text": "Number a =  [a] -  a  Returns the median of the given list of numbers.  \\\\phln\\\\math\\\\median([7, 2, 9]) // 7\n\\\\phln\\\\math\\\\median([7, 2, 10, 9]) // 8", 
            "title": "median"
        }, 
        {
            "location": "/functions/math/#modulo", 
            "text": "Number a =  a -  a -  a  Divides the first parameter by the second and returns the remainder.  \\\\phln\\\\math\\\\modulo(1, 2) // 1", 
            "title": "modulo"
        }, 
        {
            "location": "/functions/math/#multiply", 
            "text": "Number a =  a -  a -  a  Multiplies two numbers  $triple = P::multiply(3);\n$triple(7); // 21", 
            "title": "multiply"
        }, 
        {
            "location": "/functions/math/#product", 
            "text": "Number a =  [a] -  a  Multiplies together all the elements of a list.  P::product([2, 4, 6, 8, 100, 1]); // 38400", 
            "title": "product"
        }, 
        {
            "location": "/functions/math/#subtract", 
            "text": "Number a =  a -  a -  a  Subtracts its second argument from its first argument.  $complementaryAngle = P::subtract(90);\n$complementaryAngle(30); //=  60", 
            "title": "subtract"
        }, 
        {
            "location": "/functions/math/#sum", 
            "text": "[Number] -  Number  Adds together all the elements of a list.  P::sum([1, 2, 3, 4]); // 10", 
            "title": "sum"
        }, 
        {
            "location": "/functions/object/", 
            "text": "eqProps\n\n\nk -\n {k: v} -\n {k: v} -\n Boolean\n\n\nReports whether two objects have the same value, in \nP::equals\n terms, for the specified property.\n\n\nP::eqProps('name', ['name' =\n 'Jon'], ['name' =\n 'Jon']); // true\n\n\n\n\nkeys\n\n\n{k: v} -\n [k]\n\n\nReturns a list containing the names of array keys.\n\n\nP::keys(['a' =\n 1, 'b' =\n 1]); // ['a', 'b']\n\n\n\n\nmerge\n\n\n{k: v} -\n {k: v} -\n {k: v}\n\n\nCreate a new object with the keys of the first object merged with the keys of the second object. If a key exists in both objects, the value from the second object will be used.\n\n\n$toDefaults = P::partial(P::merge, [P::__, ['x' =\n 0]);\n$toDefaults(['x' =\n 2, 'y' =\n 1]); // ['x' =\n 0, 'y' =\n 1]\n\n\n\n\nobjOf\n\n\nString -\n a -\n { String: a }\n\n\nCreates an object containing a single key:value pair.\n\n\nP::objOf('foo', 'bar'); // ['foo' =\n 'bar']\n\n\n\n\nomit\n\n\n[String] -\n {String: *} -\n {String: *}\n\n\nReturns a partial copy of an object omitting the keys specified.\n\n\nP::omit(['a', 'c'], ['a' =\n 1, 'b' =\n 2, 'c' =\n 3]); // ['b' =\n 2]\n\n\n\n\npath\n\n\nString -\n {k: v} -\n v|Null\n\n\nReturns nested value using \"dot notation\".\n\n\nP::path('a.b', ['a' =\n ['b' =\n 'foo']]); // 'foo'\nP::path('a.b.c', ['a' =\n ['b' =\n 'foo']]); // null\n\n\n\n\npathOr\n\n\nString -\n a -\n {k: v} -\n v | a\n\n\nReturns nested value using \"dot notation\". If key is not defined, or value is NULL default value will be returned.\n\n\nP::pathOr('a.b', 'foo', ['a' =\n ['b' =\n 1]]); // 1\nP::pathOr('a.b', 'foo', ['a' =\n ['b' =\n 0]]); // 0\nP::pathOr('a.b', 'foo', ['a' =\n ['b' =\n null]]); // 'foo'\nP::pathOr('a.b', 'foo', ['a' =\n 1]); // 'foo'\n\n\n\n\npick\n\n\n[String] -\n {String: *} -\n {String: *}\n\n\nReturns a partial copy of an object containing only the keys specified. If the key does not exist, the property is ignored.\n\n\nP::pick(['a'], ['a' =\n 1, 'b' =\n 2]); // ['a' =\n 1]\n\n\n\n\nprop\n\n\nk -\n {k: v} -\n v\n\n\nReturns a function that when supplied an array returns the indicated key of that key, if it exists.\n\n\nprops\n\n\n[k] -\n {k: v} -\n [v]\n\n\nActs as multiple \nprop\n: array of keys in, array of values out. Preserves order.\n\n\n$fullName = P::compose(P::join(' '), P::props(['firstName', 'lastName']));\n$fullName(['lastName' =\n 'Snow', 'firstName' =\n 'Jon']); // 'Jon Snow'\n\n\n\n\ntoPairs\n\n\nString k =\n { k: v } -\n [[k, v]]\n\n\nConverts an object into an array of key-value arrays.\n\n\nNote that order of output is not guaranteed.\n\n\nP::toPairs(['foo' =\n 1, 'bar' =\n 2]); // [['foo', 1], ['bar', 2]]\n\n\n\n\nvalues\n\n\n{k: v} -\n [v]\n\n\nReturns values of supplied object\n\n\nwhere\n\n\n{String: (* -\n Boolean)} -\n {String: *} -\n Boolean\n\n\nTakes a spec object and a test object; returns \ntrue\n if the test satisfies the spec. Each of the spec's properties must be a predicate function. Each predicate is applied to the value of the corresponding property of the test object. where returns \ntrue\n if all the predicates return true, false otherwise.\n\n\nwhere\n is well suited to declaratively expressing constraints for other functions such as \nfilter\n and \nfind\n.\n\n\n$verifyJon = P::where([\n    'firstName' =\n P::equals('Jon'),\n    'lastName' =\n P::equals('Snow'),\n]);\n\n$verifyJon(['firstName' =\n 'Jon', 'lastName' =\n 'Snow', 'house' =\n 'Stark']); // true\n\n\n\n\nwhereEq\n\n\n{String: *} -\n {String: *} -\n Boolean\n\n\nTakes a spec object and a test object; returns \ntrue\n if the test satisfies the spec, false otherwise. An object satisfies the spec if, for each of the spec's properties, accessing that property of the object gives the same value (in \nP::equals()\n terms) as accessing that property of the spec.\n\n\n$verifyJon = P::whereEq(['firstName' =\n 'Jon', 'lastName' =\n 'Snow']);\n$verifyJon(['firstName' =\n 'Jon', 'lastName' =\n 'Snow']); // true", 
            "title": "Object"
        }, 
        {
            "location": "/functions/object/#eqprops", 
            "text": "k -  {k: v} -  {k: v} -  Boolean  Reports whether two objects have the same value, in  P::equals  terms, for the specified property.  P::eqProps('name', ['name' =  'Jon'], ['name' =  'Jon']); // true", 
            "title": "eqProps"
        }, 
        {
            "location": "/functions/object/#keys", 
            "text": "{k: v} -  [k]  Returns a list containing the names of array keys.  P::keys(['a' =  1, 'b' =  1]); // ['a', 'b']", 
            "title": "keys"
        }, 
        {
            "location": "/functions/object/#merge", 
            "text": "{k: v} -  {k: v} -  {k: v}  Create a new object with the keys of the first object merged with the keys of the second object. If a key exists in both objects, the value from the second object will be used.  $toDefaults = P::partial(P::merge, [P::__, ['x' =  0]);\n$toDefaults(['x' =  2, 'y' =  1]); // ['x' =  0, 'y' =  1]", 
            "title": "merge"
        }, 
        {
            "location": "/functions/object/#objof", 
            "text": "String -  a -  { String: a }  Creates an object containing a single key:value pair.  P::objOf('foo', 'bar'); // ['foo' =  'bar']", 
            "title": "objOf"
        }, 
        {
            "location": "/functions/object/#omit", 
            "text": "[String] -  {String: *} -  {String: *}  Returns a partial copy of an object omitting the keys specified.  P::omit(['a', 'c'], ['a' =  1, 'b' =  2, 'c' =  3]); // ['b' =  2]", 
            "title": "omit"
        }, 
        {
            "location": "/functions/object/#path", 
            "text": "String -  {k: v} -  v|Null  Returns nested value using \"dot notation\".  P::path('a.b', ['a' =  ['b' =  'foo']]); // 'foo'\nP::path('a.b.c', ['a' =  ['b' =  'foo']]); // null", 
            "title": "path"
        }, 
        {
            "location": "/functions/object/#pathor", 
            "text": "String -  a -  {k: v} -  v | a  Returns nested value using \"dot notation\". If key is not defined, or value is NULL default value will be returned.  P::pathOr('a.b', 'foo', ['a' =  ['b' =  1]]); // 1\nP::pathOr('a.b', 'foo', ['a' =  ['b' =  0]]); // 0\nP::pathOr('a.b', 'foo', ['a' =  ['b' =  null]]); // 'foo'\nP::pathOr('a.b', 'foo', ['a' =  1]); // 'foo'", 
            "title": "pathOr"
        }, 
        {
            "location": "/functions/object/#pick", 
            "text": "[String] -  {String: *} -  {String: *}  Returns a partial copy of an object containing only the keys specified. If the key does not exist, the property is ignored.  P::pick(['a'], ['a' =  1, 'b' =  2]); // ['a' =  1]", 
            "title": "pick"
        }, 
        {
            "location": "/functions/object/#prop", 
            "text": "k -  {k: v} -  v  Returns a function that when supplied an array returns the indicated key of that key, if it exists.", 
            "title": "prop"
        }, 
        {
            "location": "/functions/object/#props", 
            "text": "[k] -  {k: v} -  [v]  Acts as multiple  prop : array of keys in, array of values out. Preserves order.  $fullName = P::compose(P::join(' '), P::props(['firstName', 'lastName']));\n$fullName(['lastName' =  'Snow', 'firstName' =  'Jon']); // 'Jon Snow'", 
            "title": "props"
        }, 
        {
            "location": "/functions/object/#topairs", 
            "text": "String k =  { k: v } -  [[k, v]]  Converts an object into an array of key-value arrays.  Note that order of output is not guaranteed.  P::toPairs(['foo' =  1, 'bar' =  2]); // [['foo', 1], ['bar', 2]]", 
            "title": "toPairs"
        }, 
        {
            "location": "/functions/object/#values", 
            "text": "{k: v} -  [v]  Returns values of supplied object", 
            "title": "values"
        }, 
        {
            "location": "/functions/object/#where", 
            "text": "{String: (* -  Boolean)} -  {String: *} -  Boolean  Takes a spec object and a test object; returns  true  if the test satisfies the spec. Each of the spec's properties must be a predicate function. Each predicate is applied to the value of the corresponding property of the test object. where returns  true  if all the predicates return true, false otherwise.  where  is well suited to declaratively expressing constraints for other functions such as  filter  and  find .  $verifyJon = P::where([\n    'firstName' =  P::equals('Jon'),\n    'lastName' =  P::equals('Snow'),\n]);\n\n$verifyJon(['firstName' =  'Jon', 'lastName' =  'Snow', 'house' =  'Stark']); // true", 
            "title": "where"
        }, 
        {
            "location": "/functions/object/#whereeq", 
            "text": "{String: *} -  {String: *} -  Boolean  Takes a spec object and a test object; returns  true  if the test satisfies the spec, false otherwise. An object satisfies the spec if, for each of the spec's properties, accessing that property of the object gives the same value (in  P::equals()  terms) as accessing that property of the spec.  $verifyJon = P::whereEq(['firstName' =  'Jon', 'lastName' =  'Snow']);\n$verifyJon(['firstName' =  'Jon', 'lastName' =  'Snow']); // true", 
            "title": "whereEq"
        }, 
        {
            "location": "/functions/relation/", 
            "text": "clamp\n\n\nNumber a =\n a -\n a -\n a -\n a\n\n\nRestricts a number to be within a range.\n\n\nP::clamp(-1, 1, -100); // -1\nP::clamp(-1, 1, 100); // 1\nP::clamp(-1, 1, 0); // 0\n\n\n\n\ndifference\n\n\n[*] -\n [*] -\n [*]\n\n\nFinds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n\n\nP::difference([1, 2, 3, 4], [3, 4, 5, 6]); // [1, 2]\n\n\n\n\nequals\n\n\na -\n b -\n Boolean\n\n\nReturns \ntrue\n if its arguments are equivalent, \nfalse\n otherwise.\n\n\nP::equals(1, 1); // true\nP::equals(1, '1'); // false\nP::equals(1, 2); // false\n\n\n\n\ngt\n\n\nOrd a =\n a -\n a -\n Boolean\n\n\nReturns \ntrue\n if the first argument is greater than the second; \nfalse\n otherwise.\n\n\nP::gt(2, 1); // true\n\n\n\n\ngte\n\n\nOrd a =\n a -\n a -\n Boolean\n\n\nReturns \ntrue\n if the first argument is greater than or equal to the second; \nfalse\n otherwise.\n\n\nP::gte(2, 1); // true\nP::gte(2, 2); // true\nP::gte(2, 3); // false\n\n\n\n\nintersection\n\n\n[*] -\n [*] -\n [*]\n\n\nCombines two lists into a set composed of those elements common to both lists.\n\n\nP::intersection([1, 2, 3, 4], [6, 4, 5]); // [4]\n\n\n\n\nlt\n\n\nOrd a =\n a -\n a -\n Boolean\n\n\nReturns \ntrue\n if the first argument is less than the second; \nfalse\n otherwise.\n\n\nP::lt(1, 2); // true\nP::lt(3, 2); // false\nP::lt(2, 2); // false\n\n\n\n\nlte\n\n\nOrd a =\n a -\n a -\n Boolean\n\n\nReturns \ntrue\n if the first argument is less than or equal to the second; \nfalse\n otherwise.\n\n\nP::lte(1, 2); // true\n\n\n\n\nmax\n\n\na -\n a -\n a\n\n\nReturns the larger of its two arguments.\n\n\nmin\n\n\na -\n a -\n a\n\n\nReturns the smaller of its two arguments.\n\n\nP::min(1, -1); // -1\n\n\n\n\npathEq\n\n\nString -\n a -\n {a} -\n Boolean\n\n\nDetermines whether a nested path on an object has a specific value, in \nequals()\n terms.\n\n\nP::pathEq('foo.bar', 1, ['foo' =\n ['bar' =\n 1]]); // true\n\n\n\n\npropEq\n\n\nk -\n a -\n {k: a} -\n Boolean\n\n\nReturns \ntrue\n if the specified object property is equal, in \nequals()\n terms, to the given value; \nfalse\n otherwise.\n\n\nP::propEq('name', 'Jon', ['name' =\n 'Jon']); // true", 
            "title": "Relation"
        }, 
        {
            "location": "/functions/relation/#clamp", 
            "text": "Number a =  a -  a -  a -  a  Restricts a number to be within a range.  P::clamp(-1, 1, -100); // -1\nP::clamp(-1, 1, 100); // 1\nP::clamp(-1, 1, 0); // 0", 
            "title": "clamp"
        }, 
        {
            "location": "/functions/relation/#difference", 
            "text": "[*] -  [*] -  [*]  Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.  P::difference([1, 2, 3, 4], [3, 4, 5, 6]); // [1, 2]", 
            "title": "difference"
        }, 
        {
            "location": "/functions/relation/#equals", 
            "text": "a -  b -  Boolean  Returns  true  if its arguments are equivalent,  false  otherwise.  P::equals(1, 1); // true\nP::equals(1, '1'); // false\nP::equals(1, 2); // false", 
            "title": "equals"
        }, 
        {
            "location": "/functions/relation/#gt", 
            "text": "Ord a =  a -  a -  Boolean  Returns  true  if the first argument is greater than the second;  false  otherwise.  P::gt(2, 1); // true", 
            "title": "gt"
        }, 
        {
            "location": "/functions/relation/#gte", 
            "text": "Ord a =  a -  a -  Boolean  Returns  true  if the first argument is greater than or equal to the second;  false  otherwise.  P::gte(2, 1); // true\nP::gte(2, 2); // true\nP::gte(2, 3); // false", 
            "title": "gte"
        }, 
        {
            "location": "/functions/relation/#intersection", 
            "text": "[*] -  [*] -  [*]  Combines two lists into a set composed of those elements common to both lists.  P::intersection([1, 2, 3, 4], [6, 4, 5]); // [4]", 
            "title": "intersection"
        }, 
        {
            "location": "/functions/relation/#lt", 
            "text": "Ord a =  a -  a -  Boolean  Returns  true  if the first argument is less than the second;  false  otherwise.  P::lt(1, 2); // true\nP::lt(3, 2); // false\nP::lt(2, 2); // false", 
            "title": "lt"
        }, 
        {
            "location": "/functions/relation/#lte", 
            "text": "Ord a =  a -  a -  Boolean  Returns  true  if the first argument is less than or equal to the second;  false  otherwise.  P::lte(1, 2); // true", 
            "title": "lte"
        }, 
        {
            "location": "/functions/relation/#max", 
            "text": "a -  a -  a  Returns the larger of its two arguments.", 
            "title": "max"
        }, 
        {
            "location": "/functions/relation/#min", 
            "text": "a -  a -  a  Returns the smaller of its two arguments.  P::min(1, -1); // -1", 
            "title": "min"
        }, 
        {
            "location": "/functions/relation/#patheq", 
            "text": "String -  a -  {a} -  Boolean  Determines whether a nested path on an object has a specific value, in  equals()  terms.  P::pathEq('foo.bar', 1, ['foo' =  ['bar' =  1]]); // true", 
            "title": "pathEq"
        }, 
        {
            "location": "/functions/relation/#propeq", 
            "text": "k -  a -  {k: a} -  Boolean  Returns  true  if the specified object property is equal, in  equals()  terms, to the given value;  false  otherwise.  P::propEq('name', 'Jon', ['name' =  'Jon']); // true", 
            "title": "propEq"
        }, 
        {
            "location": "/functions/string/", 
            "text": "match\n\n\nRegExp -\n String -\n String|Null\n\n\nRegExp -\n String -\n [String]\n\n\nTests a regular expression against a String. Returns found string, or \nNULL\n. When regular expression has 'global' modifier function will return array of found strings.\n\n\nP::match('/([a-z](o))/i', 'Lorem ipsum dolor'); // 'Lo'\nP::match('/([a-z](o))/ig', 'Lorem ipsum dolor'); // ['Lo', 'do', 'lo']\n\n\n\n\nregexp\n\n\nString -\n RegExp\n\n\nConverts given string to RegExp object\n\n\nP::regexp('/foo/ig'); // =\n new \\phln\\RegExp('/foo/', 'ig');\n\n\n\n\nreplace\n\n\nRegExp -\n String -\n String -\n String\n\n\nReplace a regex match in a string with a replacement.\n\n\nWhen regular expression has 'global' modifier all matching strings will be replaced.\nOtherwise only first matching string will be replaced.\n\n\nP::replace('/foo/', 'bar', 'foo foo foo'); // 'bar foo foo'\nP::replace('/foo/g', 'bar', 'foo foo foo'); // 'bar bar bar'\n\n\n\n\nsplit\n\n\nString -\n String -\n [String]\n\n\nRegExp -\n String -\n [String]\n\n\nSplits a string into an array of strings based on the given regular expression or separator.\n\n\nIt's possible to split string\n\n\nP::split('/', 'a/b'); // ['a', 'b']\n\n\n\n\ntest\n\n\nRegExp -\n String -\n Bool\n\n\nString -\n String -\n Bool\n\n\nDetermines whether a given string matches a given regular expression.\n\n\nP::test('/foo/', 'foobar'); // true", 
            "title": "String"
        }, 
        {
            "location": "/functions/string/#match", 
            "text": "RegExp -  String -  String|Null  RegExp -  String -  [String]  Tests a regular expression against a String. Returns found string, or  NULL . When regular expression has 'global' modifier function will return array of found strings.  P::match('/([a-z](o))/i', 'Lorem ipsum dolor'); // 'Lo'\nP::match('/([a-z](o))/ig', 'Lorem ipsum dolor'); // ['Lo', 'do', 'lo']", 
            "title": "match"
        }, 
        {
            "location": "/functions/string/#regexp", 
            "text": "String -  RegExp  Converts given string to RegExp object  P::regexp('/foo/ig'); // =  new \\phln\\RegExp('/foo/', 'ig');", 
            "title": "regexp"
        }, 
        {
            "location": "/functions/string/#replace", 
            "text": "RegExp -  String -  String -  String  Replace a regex match in a string with a replacement.  When regular expression has 'global' modifier all matching strings will be replaced.\nOtherwise only first matching string will be replaced.  P::replace('/foo/', 'bar', 'foo foo foo'); // 'bar foo foo'\nP::replace('/foo/g', 'bar', 'foo foo foo'); // 'bar bar bar'", 
            "title": "replace"
        }, 
        {
            "location": "/functions/string/#split", 
            "text": "String -  String -  [String]  RegExp -  String -  [String]  Splits a string into an array of strings based on the given regular expression or separator.  It's possible to split string  P::split('/', 'a/b'); // ['a', 'b']", 
            "title": "split"
        }, 
        {
            "location": "/functions/string/#test", 
            "text": "RegExp -  String -  Bool  String -  String -  Bool  Determines whether a given string matches a given regular expression.  P::test('/foo/', 'foobar'); // true", 
            "title": "test"
        }, 
        {
            "location": "/functions/type/", 
            "text": "is\n\n\nString -\n a -\n Boolean\n\n\nSee if \nvalue\n is of given \ntype\n.\n\n\nInternally this function uses \n\\gettype()\n with few support of few aliases:\n\n \nbool\n - alias for \nboolean\n type\n\n \nfloat\n - alias for \ndouble\n type\n\n \ncallable\n - checks if $value is valid callback\n\n \nfunction\n - same as \ncallable\n\n* class FQN - will check if supplied object is instance of given class\n\n\nP::is('bool', true); // true\nP::is(\\stdClass::class, new \\stdClass); // true\nP::is(float, 1.1); // true\n\n\n\n\ntypeCond\n\n\n[[String, (*... -\n *)]] -\n (*... -\n *)\n\n\nReturns a function, \nfn\n, which encapsulates \nif/else\n, \nif/else\n, .\n\n\n.. logic. \nP::typeCond\n takes a list of [\ntype\n, \ntransformer\n] pairs. Type is converted to \npredicate\n matching type of variable (in terms of \nP::is()\n). All of the arguments to \nfn\n are applied to each of the \npredicates\n in turn until one returns a truth-y value, at which point \nfn\n returns the result of applying its arguments to the corresponding \ntransformer\n. If none of the \npredicates\n matches, \nfn\n returns null.\n\n\n$count = P::typeCond([\n    ['string', '\\\\mb_strlen'],\n    ['array', '\\\\count'],\n    [P::T, P::always(0)],\n]);\n$count('foo'); // 3\n$count(['f', 'o', 'o']); // 3\n$count(new stdClass); // 0", 
            "title": "Type"
        }, 
        {
            "location": "/functions/type/#is", 
            "text": "String -  a -  Boolean  See if  value  is of given  type .  Internally this function uses  \\gettype()  with few support of few aliases:   bool  - alias for  boolean  type   float  - alias for  double  type   callable  - checks if $value is valid callback   function  - same as  callable \n* class FQN - will check if supplied object is instance of given class  P::is('bool', true); // true\nP::is(\\stdClass::class, new \\stdClass); // true\nP::is(float, 1.1); // true", 
            "title": "is"
        }, 
        {
            "location": "/functions/type/#typecond", 
            "text": "[[String, (*... -  *)]] -  (*... -  *)  Returns a function,  fn , which encapsulates  if/else ,  if/else , .  .. logic.  P::typeCond  takes a list of [ type ,  transformer ] pairs. Type is converted to  predicate  matching type of variable (in terms of  P::is() ). All of the arguments to  fn  are applied to each of the  predicates  in turn until one returns a truth-y value, at which point  fn  returns the result of applying its arguments to the corresponding  transformer . If none of the  predicates  matches,  fn  returns null.  $count = P::typeCond([\n    ['string', '\\\\mb_strlen'],\n    ['array', '\\\\count'],\n    [P::T, P::always(0)],\n]);\n$count('foo'); // 3\n$count(['f', 'o', 'o']); // 3\n$count(new stdClass); // 0", 
            "title": "typeCond"
        }
    ]
}